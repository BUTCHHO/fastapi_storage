class NotAUserId(Exception):
    def __init__(self, path:str):
        msg = f'path {path} dont starts with user_id. Must look like \'1/folder/file.txt\''
        super().__init__(msg)from fastapi import HTTPException


class APITooManyFiles(HTTPException):
    def __init__(self):
        detail = {"message": 'Too many files were uploaded at once. Please try again with fewer files per upload.',
                  "code": 'too_many_files'}
        status_code = 429
        super().__init__(detail, status_code)from .path_http_exc import APIPathGoesBeyondLimits, APIUserStorageAlreadyExists, APIDirectoryAlreadyExists, APIEntityDoesNotExists, APIUnsupportedEntityType
from .exc import NotAUserId
from .auth import UserAlreadyExists, UserDontExists, IncorrectPassword, SessionExpired, SessionDontExists
from .auth_http_exc import APIUserAlreadyExists, APIUserDontExists, APIIncorrectPassword, APISessionDontExists, APISessionExpired, APIUnauthorized
from .config_exc import StoragePathIsNone, DatabaseUrlIsNone, CacheHostIsNone, CachePortIsNone, CacheExpireTimeIsNone, SessionMakerKeyIsNone
from .path_exc import EntityDoesNotExists, EntityIsNotADir
from .http_files_exc import APITooManyFilesclass StoragePathIsNone(Exception):
    def __init__(self):
        msg = 'STORAGE_PATH value from .env file is None. Must be filled'
        super().__init__(msg)

class DatabaseUrlIsNone(Exception):
    def __init__(self):
        msg = 'DATABASE_URL value from .env file is None. Must be filled'
        super().__init__(msg)

class CachePortIsNone(Exception):
    def __init__(self):
        msg = 'CACHE_PORT value from .env file is None. Must be filled'
        super().__init__(msg)

class CacheHostIsNone(Exception):
    def __init__(self):
        msg = 'CACHE_HOST value from .env file is None. Must be filled'
        super().__init__(msg)

class CacheExpireTimeIsNone(Exception):
    def __init__(self):
        msg = 'CACHE_EXPIRE_TIME value from .env file is None. Must be filled'
        super().__init__(msg)

class SessionMakerKeyIsNone(Exception):
    def __init__(self):
        msg = 'SESSION_MAKER_KEY value from .env file is None. Must be filled'
        super().__init__(msg)class UserAlreadyExists(Exception):
    def __init__(self, name):
        msg = f'User with name {name} already exists'
        super().__init__(msg)

class UserDontExists(Exception):
    def __init__(self, name):
        msg = f'User with name {name} does not exists'
        super().__init__(msg)

class IncorrectPassword(Exception):
    def __init__(self):
        super().__init__()

class SessionExpired(Exception):
    def __init__(self):
        super().__init__()

class SessionDontExists(Exception):
    def __init__(self):
        super().__init__()from fastapi.exceptions import HTTPException


class APIUserAlreadyExists(HTTPException):
    def __init__(self, name, detail=None, status_code=409):
        if not detail:
            detail = {"message": f'User with name {name} already exists', "code": 'user_already_exists'}
        super().__init__(status_code, detail)

class APIUserDontExists(HTTPException):
    def __init__(self, name, detail=None, status_code = 404):
        if not detail:
            detail = {"message": f'User with name {name} dont exists', "code": 'user_dont_exists'}
        super().__init__(status_code, detail)

class APIIncorrectPassword(HTTPException):
    def __init__(self, detail=None, status_code=401):
        if not detail:
            detail = {"message": f'Incorrect password', "code": 'incorrect_password'}
        super().__init__(status_code, detail)

class APISessionDontExists(HTTPException):
    def __init__(self, detail=None, status_code=404):
        if not detail:
            detail = {"message": f'Session dont exists', "code": 'session_dont_exists'}
        super().__init__(status_code, detail)

class APISessionExpired(HTTPException):
    def __init__(self):
        detail = {"message": f'Session expired', "code": 'session_expired'}
        status_code = 440
        super().__init__(status_code, detail)

class APIUnauthorized(HTTPException):
    def __init__(self):
        detail = {"message": f'you have to log in to see this page', "code": 'unauthorized'}
        status_code = 401
        super().__init__(status_code, detail)from fastapi import HTTPException

class APIPathGoesBeyondLimits(HTTPException):
    def __init__(self, path_in_storage, detail=None, status_code=403):
        if not detail:
            detail = {"message": f'path {path_in_storage} is goes beyond limits', "code": 'path_goes_beyond_limits'}
        super().__init__(status_code=status_code, detail=detail)

class APIEntityDoesNotExists(HTTPException):
    def __init__(self, path_in_storage):
        detail = {"message": f'entity at {path_in_storage} does not exists', "code": 'entity_does_not_exists'}
        status_code = 404
        super().__init__(status_code=status_code, detail=detail)

class APIUnsupportedEntityType(HTTPException):
    def __init__(self, entity_path_in_storage, detail=None, status_code=415):
        if not detail:
            detail = {"message":f'unsupported entity type {entity_path_in_storage}', "code":'unsupported_entity_type'}
        super().__init__(status_code, detail)

class APIUserStorageAlreadyExists(HTTPException):
    def __init__(self):
        status_code=409
        detail = {"message": 'Storage for this user already exists. Failed to create new storage', "code": 'user_storage_already_exists'}
        super().__init__(status_code, detail)

class APIDirectoryAlreadyExists(HTTPException):
    def __init__(self, path):
        status_code = 409
        detail = {"message": f'Directory at {path} already exists', "code":'diractory_already_exists'}
        super().__init__(status_code, detail)

from path_explorator.exceptions import EntityDoesNotExists, EntityIsNotADirfrom http.client import responses

from fastapi import UploadFile
from fastapi.testclient import TestClient


from main import app
client = TestClient(app)

def test_sign_in():
    params = {'name': 'tester1', 'password': '123'}
    response = client.post('/log-in', params=params)
    assert response.status_code == 200

def test_view_root_storage():
    url = '/storage'
    params = {"user_id": 1}
    response = client.get(url=url, params=params)
    json = response.json()
    assert response.status_code == 200
    assert 'entities' in json

def test_view_storage():
    url = '/storage/music%2Fletov?user_id=1'
    params = {"user_id": 1}
    response = client.get(url=url, params=params)
    assert  response.status_code == 200
    assert 'entities' in response.json()

def test_download_dir():
    url = '/download-entity'
    params = {"user_id": 1, "entity_path_in_storage": 'music/nirvana'}
    response = client.get(url=url, params=params)
    headers = response.headers
    content_len = int(headers['content-length'])
    assert response.status_code == 200
    assert content_len > 0

def test_download_file():
    url = '/download-entity'
    params = {"user_id": 1, "entity_path_in_storage": 'images/Desert.jpg'}
    response = client.get(url=url, params=params)
    headers = response.headers
    content_len = int(headers['content-length'])
    status_code = response.status_code
    assert status_code == 200
    assert content_len > 0

def test_upload_entity():
    print('not_impl')from logic import Archivator
from config import STORAGE_PATH

archiver = Archivator()

def test_create_large_zip():
    path_to_archivable = f"{STORAGE_PATH}/music"
    zip = archiver.create_large_zip(path_to_archivable)
    zip_name = zip.name
    expected_zip_name = 'music.zip'
    assert zip_name == expected_zip_name
    archiver.cleanup_temp_files()

from path_explorator import PathGoesBeyondLimits

from exceptions.exc import NotAUserId
from utils import Logger, PathCutter, PathJoiner, PathValidEnsurer

from config import STORAGE_PATH

logger = Logger()
cutter = PathCutter()
joiner = PathJoiner(STORAGE_PATH)
ensurer = PathValidEnsurer(STORAGE_PATH)

def test_cutter():
    failure = False
    expected_path = '/folder/file.txt'
    tmplt = expected_path
    paths = [f'/5{tmplt}', f'/321{tmplt}', f'/5039{tmplt}', f'/59438729{tmplt}']
    invalid_paths = [f'/foo{tmplt}', f'/f312oo{tmplt}', f'/21foo{tmplt}', f'/foo123{tmplt}', f'/1f2f3f4o5o{tmplt}']
    for path in paths:
        cut_path = cutter.cut_user_id_from_storage_path(path)
        assert cut_path == expected_path
    for invalid_path in invalid_paths:
        try:
            cutter.cut_user_id_from_storage_path(invalid_path)
            failure = True # если схавал невалидный путь и не поднял исключение
        except NotAUserId:
            pass
    assert failure == False

def test_joiner_join_with_root_path():
    path_to_dir = 'very/cool/dir'
    joined_path_to_dir = joiner.join_with_root_path(path_to_dir)
    expected_path_to_dir = f'{STORAGE_PATH}/{path_to_dir}'
    assert joined_path_to_dir == expected_path_to_dir
    path_to_file = 'very/cool/dir/file.txt'
    joined_path_to_file = joiner.join_with_root_path(path_to_file)
    expected_path_to_file = f'{STORAGE_PATH}/{path_to_file}'
    assert  joined_path_to_file == expected_path_to_file

def test_joiner_create_absolute_path():
    user_id_int = 1
    user_id_str = '1'
    path_to_dir = 'very/cool/dir'
    abs_path_dir_int_id = joiner.create_absolute_path(user_id_int, path_to_dir)
    abs_path_dir_str_id = joiner.create_absolute_path(user_id_str, path_to_dir)
    expected_path_to_dir = f'{STORAGE_PATH}/{user_id_str}/{path_to_dir}'
    assert abs_path_dir_str_id == abs_path_dir_int_id == expected_path_to_dir
    path_to_file = 'very/cool/dir/file.txt'
    abs_path_file_int_id = joiner.create_absolute_path(user_id_int, path_to_file)
    abs_path_file_str_id = joiner.create_absolute_path(user_id_str, path_to_file)
    expected_path_to_file = f'{STORAGE_PATH}/{user_id_str}/{path_to_file}'
    assert abs_path_file_str_id == abs_path_file_int_id == expected_path_to_file

def test_ensurer_goes_beyond_limits():
    beyond_path = '/home'
    beyond_rel_path = f'{ensurer.root}/../../dir'
    safe_path = f'{ensurer.root}/very/cool/dir'
    is_unsafe = ensurer.is_goes_beyond_limits(beyond_path)
    is_unsafe_rel = ensurer.is_goes_beyond_limits(beyond_rel_path)
    is_safe = not ensurer.is_goes_beyond_limits(safe_path)
    assert is_unsafe == is_unsafe_rel == is_safe == True
from .auth import AuthDependfrom fastapi import Request
from exceptions.auth_http_exc import APIIncorrectPassword, APIUserDontExists
from exceptions.auth import IncorrectPassword, UserDontExists

class AuthDepend:
    def __init__(self, auth_handler):
        self.auth_handler = auth_handler

    def auth(self, request: Request):
        session_id = request.cookies.get('session_id')
        return self.auth_handler.auth_with_session_id(session_id)

    def ask_for_password(self, password, user):
        try:
            self.auth_handler.check_password(password, user)
        except IncorrectPassword:
            raise APIIncorrectPassword
        except UserDontExists:
            raise UserDontExists('')
from dotenv import load_dotenv
from os import getenv

load_dotenv('.env')

STORAGE_PATH = getenv('STORAGE_PATH')
DATABASE_URL = getenv('DATABASE_URL')
SESSION_EXPIRE_TIME = getenv('SESSION_EXPIRE_TIME_DAYS')
SESSION_COOKIES_EXPIRE_TIME = getenv('SESSION_COOKIES_EXPIRE_TIME_SECONDS')
CACHE_HOST = getenv('CACHE_HOST')
CACHE_PORT = int(getenv('CACHE_PORT'))
CACHE_EXPIRE_TIME = getenv('CACHE_EXPIRE_TIME_SECONDS')


assert STORAGE_PATH is not None
assert DATABASE_URL is not None
assert SESSION_EXPIRE_TIME is not None
assert SESSION_COOKIES_EXPIRE_TIME is not None
assert CACHE_PORT is not None
assert CACHE_HOST is not None
assert CACHE_EXPIRE_TIME is not Nonefrom .reader import ModelReader
from .actor import ModelActorfrom .parent_access import ParentAccess

class ModelActor(ParentAccess):
    def __init__(self, model, logger):
        super().__init__(model, logger)

    def create_and_write_record_to_db(self, **kwargs):
        record = self.create_record(**kwargs)
        self.write_record_to_db(record)

    def write_record_to_db(self, record):
        session = self.session()
        try:
            session.add(record)
            session.commit()
        finally:
            session.close()

    def create_record(self, **kwargs):
        try:
            return self.model(**kwargs)
        except Exception as e:
            self.logger.log(e)

    def delete_record_by_id(self, id):
        session = self.session()
        try:
            session.query(self.model).filter_by(id=id).delete()
            session.commit()
        except Exception as e:
            self.logger.log(e)
            session.rollback()
        finally:
            session.close()

    def delete_record_by_kwargs(self, **kwargs):
        session = self.session()
        try:
            session.query(self.model).filter_by(**kwargs).delete()
            session.commit()
        except Exception as e:
            self.logger.log(e)
            session.rollback()
        finally:
            session.close()from sqlalchemy.orm import sessionmaker
from alchemy.models import engine

class ParentAccess:
    def __init__(self, model, logger):
        self.session = sessionmaker(engine)
        self.model = model
        self.logger = loggerfrom sqlalchemy.orm import Session

from .parent_access import ParentAccess

class ModelReader(ParentAccess):
    def __init__(self, model, logger):
        super().__init__(model, logger)

    def get_by_id(self, id):
        session = self.session()
        try:
            return session.query(self.model).filter_by(id=id).first()
        except Exception as e:
            self.logger.log(e)
        finally:
            session.close()

    def get_by_kwargs(self, **kwargs):
        session = self.session()
        try:
             return session.query(self.model).filter_by(**kwargs).first()
        except Exception as e:
            self.logger.log(e)
        finally:
            session.close()

    def does_record_with_id_exists(self, id):
        session: Session = self.session()
        try:
            return session.query(self.model).filter_by(id=id).exists()
        except Exception as e:
            self.logger.log(e)
        finally:
            session.close()

    def does_record_with_kwargs_exists(self, **kwargs):
        session = self.session()
        try:
            return session.query(self.model).filter_by(**kwargs).exists()
        except Exception as e:
            self.logger.log(e)
        finally:
            session.close()from .interfaces import IArchivator, IPathValidator, IStorageReader, IStorageWriter, ILogger, IPathJoiner, IPathCutter, IModelReader, IModelActor, ITimeHandlerfrom typing import Callable
from abc import ABC, abstractmethod

class IStorageReader(ABC):
    @abstractmethod
    def get_name(self,path:str) -> str: pass
    @abstractmethod
    def is_dir(self, path:str) -> bool: pass
    @abstractmethod
    def is_file(self, path:str) -> bool: pass
    @abstractmethod
    def join_with_root_path(self, path:str) -> str: pass
    @abstractmethod
    def get_all_entitynames_in_dir(self, path: str) -> list[str]: pass

class IStorageWriter(ABC):
    @abstractmethod
    async def async_write_from_fastapi_uploadfile_to_file(self, source_file, output_file_path:str) -> None: pass
    @abstractmethod
    def create_dir(self, path: str, name: str, exist_ok=True): pass
    @abstractmethod
    def create_file(self, path: str, name: str, exist_ok=True): pass
    @abstractmethod
    def delete_entity(self, path: str | None) -> None: pass

class IArchivator(ABC):
    @abstractmethod
    def create_large_zip(self, path: str) -> str: pass

class IPathValidator(ABC):
    @abstractmethod
    def raise_if_path_invalid(self, path:str) -> None: pass
    @abstractmethod
    def raise_if_goes_beyond_limits(self, path:str) -> None: pass
    @abstractmethod
    def is_goes_beyond_limits(self, path:str) -> bool: pass
    @abstractmethod
    def is_exists(self, path:str) -> bool: pass

class IPathJoiner(ABC):
    @abstractmethod
    def join_paths(self, path1: str, path2: str) -> str: pass

class ILogger(ABC):
    @abstractmethod
    def log(self, exception) -> None: pass
    @abstractmethod
    def decor_log(self, func) -> Callable: pass

class IPathCutter(ABC):
    @abstractmethod
    def get_user_id_from_rel_path(self, path:str) -> str: pass
    @abstractmethod
    def get_user_id_from_abs_path(self, path: str) -> str: pass
    @abstractmethod
    def remove_id_from_rel_path(self, path: str) -> str: pass
class IModelReader(ABC):
    @abstractmethod
    def get_by_id(self, id: int): pass
    @abstractmethod
    def get_by_kwargs(self, **kwargs): pass
    @abstractmethod
    def does_record_with_kwargs_exists(self, **kwargs) -> bool: pass


class IModelActor(ABC):
    @abstractmethod
    def create_and_write_record_to_db(self, **kwargs): pass
    @abstractmethod
    def create_record(self, **kwargs): pass
    @abstractmethod
    def write_record_to_db(self, record): pass
    @abstractmethod
    def delete_record_by_kwargs(self, **kwargs): pass
    @abstractmethod
    def delete_record_by_id(self, id): pass

class ITimeHandler(ABC):
    @abstractmethod
    def is_date_future(self, date) -> bool: pass
    @abstractmethod
    def add_days_to_current_date(self, days) -> object: pass
    @abstractmethod
    def get_today_date(self) -> object: pass
    @abstractmethod
    def get_str_today_date(self) -> str: passfrom .cache_handler import MemCacher, RedisCacher
class Cacher:
    def __init__(self, client, expire_time):
        self.client = client
        self.expire_time = expire_time

    def get_data(self, key):
        raise NotImplementedError

    def put_data(self, key, value):
        raise NotImplementedError

    def delete_data(self, key):
        raise NotImplementedError

class MemCacher(Cacher):
    def __init__(self, memcache_client, data_expire_time):
        super().__init__(memcache_client, data_expire_time)

    def get_data(self, key):
        return self.client.get(key)

    def put_data(self, key, value):
        self.client.add(key, value, self.expire_time)

    def delete_data(self, key):
        self.client.delete(key)

class RedisCacher(Cacher):
    def __init__(self, redis_client, data_expire_time):
        super().__init__(redis_client, data_expire_time)

    def get_data(self, key):
        return self.client.get(key)

    def put_data(self, key, value):
        self.client.set(key, value, ex=self.expire_time, nx=True)

    def delete_data(self, key):
        self.client.delete(key)

    def is_data_exists(self, key):
        return self.client.exists(key)from interfaces import IModelActor


class SessionDeleter:
    def __init__(self, cacher, session_actor):
        self.cacher = cacher
        self.session_actor: IModelActor = session_actor

    def delete_session(self, session_id):
        """
        MAKE SURE YOU DELETE SESSION_ID FROM USER COOKIES!!!
        :param session_id:
        :return:
        """
        self.cacher.delete_data(session_id)
        self.session_actor.delete_record_by_id(session_id)from .session_maker import SessionMaker
from .user_getter import UserGetter
from .registration import UserRegistration
from .session_validator import SessionValidator
from .authentication import UserAuthentication
from .session_deleter import SessionDeleterfrom exceptions import SessionExpired, SessionDontExists

class UserGetter:
    def __init__(self, user_reader, session_reader, cacher, session_validator):
        self.session_reader = session_reader
        self.user_reader = user_reader
        self.cacher = cacher
        self.session_validator = session_validator


    def _get_user_from_db(self, user_id):
        return self.user_reader.get_by_kwargs(id=user_id)

    def _get_session_from_db(self, id):
        return self.session_reader.get_by_id(id)

    def _get_user_if_session_not_in_cache(self, session_id):
        session = self._get_session_from_db(session_id)
        if not session:
            raise SessionDontExists
        self.session_validator.validate_session_or_raise(session)
        return self._get_user_from_db(session.user_id)

    def get_user_by_session_id(self, session_id):
        user_id = (self.cacher.get_data(session_id))
        if not user_id:
            return self._get_user_if_session_not_in_cache(session_id)
        user_id = int(user_id)
        return self._get_user_from_db(user_id)

from interfaces import ITimeHandler
from exceptions import SessionExpired

class SessionValidator:
    def __init__(self, time_handler):
        self.time_handler: ITimeHandler = time_handler

    def is_session_expired(self, session_expire_date):
        if self.time_handler.is_date_future(session_expire_date):
            return False
        return True

    def validate_session_or_raise(self, session):
        if self.is_session_expired(session.expire_date):
            raise SessionExpired()
        return True
from interfaces import IModelReader
from exceptions import UserDontExists, IncorrectPassword, SessionExpired


class UserAuthentication:
    def __init__(self, user_reader, session_maker, user_getter, logger, hasher):
        self.user_reader: IModelReader = user_reader
        self.session_maker = session_maker
        self.hasher = hasher
        self.logger = logger
        self.user_getter = user_getter


    def _get_user_by_name(self, name):
        return self.user_reader.get_by_kwargs(name=name)

    def validate_user_and_password(self, user_name, user, psw):
        if not user:
            raise UserDontExists(user_name)
        if not self.hasher.check_password(psw, user.password):
            raise IncorrectPassword

    def _make_session(self, user_id):
        return self.session_maker.make_session(user_id)

    def make_session_by_name_and_psw(self, name, psw):
        user = self._get_user_by_name(name)
        self.validate_user_and_password(name, user, psw)
        session_id = self._make_session(user.id)
        return session_id

    def auth_by_session_id(self, session_id):
        return self.user_getter.get_user_by_session_id(session_id)


from interfaces import IModelActor

class SessionMaker:
    def __init__(self, session_expire_time, session_access, time_handler, hasher, cacher):
        self.expire_time = session_expire_time
        self._access: IModelActor = session_access
        self.time_handler = time_handler
        self.hasher = hasher
        self.cacher = cacher

    def _get_expire_date(self):
        return self.time_handler.add_days_to_current_date(self.expire_time)

    def _create_session_id(self):
        hashed_id = self.hasher.create_session_id_hash()
        return hashed_id

    def _create_session_obj(self, user_id):
        session_id = self._create_session_id()
        expire_date = self._get_expire_date()
        session_record = self._access.create_record(id=session_id, expire_date=expire_date, user_id=user_id)
        return session_record

    def make_session(self, user_id):
        session = self._create_session_obj(user_id)
        session_id = session.id
        self._access.write_record_to_db(session)
        self.cacher.put_data(session_id, user_id)
        return session_idfrom exceptions import UserAlreadyExists
from sqlalchemy.exc import IntegrityError
from psycopg2.errors import UniqueViolation

class UserRegistration:
    def __init__(self,user_actor, hasher, logger):
        self._user_actor = user_actor
        self.hasher = hasher
        self.logger = logger

    def create_user(self, name, password):
        try:
            password = self.hasher.generate_psw_hash(password)
            self._user_actor.create_and_write_record_to_db(name=name, password=password)
        except IntegrityError as integrity_error:
            if isinstance(integrity_error.orig, UniqueViolation):
                raise UserAlreadyExists(name)
        except Exception as e:
            self.logger.log(e)


from .view_storage import view_storage_router
from .storage_acting import storage_acting_router
from .upload import upload_router
from .authorization import auth_router
from .download import download_routerfrom .router import download_routerfrom fastapi import APIRouter, BackgroundTasks, Query, Depends

from .schemas.query import DownloadQuery
from .endpoint_handlers import FileResponseHandler
from app.singletones import archivator, logger, path_joiner, path_ensurer, storage_reader
from app.routes.dependencies import auth_depend

download_router = APIRouter()

file_response_handler = FileResponseHandler(archivator, storage_reader, logger, path_ensurer, path_joiner)



@download_router.get('/download-entity')
def download_entity_endpoint(background_tasks: BackgroundTasks, params: DownloadQuery = Query(), user=Depends(auth_depend.auth)):
    response = file_response_handler.get_response(user.id, params.entity_path_in_storage)
    background_tasks.add_task(archivator.cleanup_temp_files)
    return responsefrom pydantic import BaseModel


class DownloadQuery(BaseModel):
    entity_path_in_storage: str
from fastapi.responses import FileResponse

from interfaces import IStorageReader, IArchivator, ILogger
from exceptions import APIEntityDoesNotExists, APIUnsupportedEntityType
from utils import get_encoded_string


class FileResponseHandler:
    def __init__(self, archivator, storage_reader, logger, path_validator, path_joiner):
        self.archivator: IArchivator = archivator
        self.storage_reader: IStorageReader = storage_reader
        self.path_joiner = path_joiner
        self.logger: ILogger = logger
        self.ensurer = path_validator
        self.encode_string = get_encoded_string

    def _make_response(self, path_to_entity):
        try:
            str_path_to_entity = path_to_entity.__str__()
            entity_name = self.storage_reader.get_name(str_path_to_entity)
            encoded_entity_name = self.encode_string(entity_name)
            return FileResponse(path_to_entity,
                                filename=f'{entity_name}',
                                headers={"Content-Disposition": f"attachment; filename*=UTF-8''{encoded_entity_name}"},
    )
        except Exception as e:
            self.logger.log(e)
            raise e

    def get_zip_file_response(self, path_in_storage_with_id):
        try:
            absolute_path_dir = self.storage_reader.join_with_root_path(path_in_storage_with_id)
            zip_path = self.archivator.create_large_zip(absolute_path_dir)
            return self._make_response(zip_path)
        except Exception as e:
            self.logger.log(e)

    def get_file_response(self, path_in_storage_with_id):
        absolute_path_file = self.storage_reader.join_with_root_path(path_in_storage_with_id)
        return self._make_response(absolute_path_file)


    def get_response(self, user_id, entity_path_in_storage):
        entity_path_in_storage = self.path_joiner.join_paths(str(user_id), entity_path_in_storage)
        self.ensurer.ensure_path_safety(str(user_id), entity_path_in_storage)
        if not self.ensurer.is_exists(entity_path_in_storage):
            raise APIEntityDoesNotExists(entity_path_in_storage)
        if self.storage_reader.is_dir(entity_path_in_storage):
            return self.get_zip_file_response(entity_path_in_storage)
        if self.storage_reader.is_file(entity_path_in_storage):
            return self.get_file_response(entity_path_in_storage)
        else:
            raise APIUnsupportedEntityType(entity_path_in_storage=entity_path_in_storage)

from .file_response_handler import FileResponseHandlerfrom .router import view_storage_routerfrom fastapi import APIRouter, Depends
from app.singletones import storage_reader, logger, path_joiner, path_cutter, path_ensurer
from .schemas.response import ViewStorageResponse
from .endpoint_handlers import StorageViewHandler
from app.routes.dependencies import auth_depend

view_storage_router = APIRouter()

storage_view_handler = StorageViewHandler(storage_reader, logger, path_joiner, path_cutter, path_ensurer)


@view_storage_router.get('/storage', response_model=ViewStorageResponse)
def view_storage_root(entity_path_in_storage = '', user=Depends(auth_depend.auth)):
    entities = storage_view_handler.get_list_of_entities(user.id, entity_path_in_storage)
    return {"entities": entities}


@view_storage_router.get('/storage/{entity_path_in_storage:path}', response_model=ViewStorageResponse)
async def view_storage(entity_path_in_storage: str, user=Depends(auth_depend.auth)):
    entities = storage_view_handler.get_list_of_entities(user.id, entity_path_in_storage)
    return {"entities": entities}from pydantic import BaseModel


class ViewStorageResponse(BaseModel):
    entities: listfrom .storage_view_handler import StorageViewHandlerfrom fastapi import HTTPException

from exceptions import APIEntityDoesNotExists, EntityDoesNotExists
from interfaces import ILogger, IStorageReader, IPathCutter


class StorageViewHandler:
    def __init__(self, storage_reader, logger, path_joiner, path_cutter, path_ensurer):
        self.storage_reader: IStorageReader = storage_reader
        self.path_ensurer = path_ensurer
        self.logger: ILogger = logger
        self.path_joiner = path_joiner
        self.path_cutter: IPathCutter = path_cutter

    def _get_abs_path(self, user_id, path_to_dir):
        path_with_user_id = self.path_joiner.join_paths(user_id, path_to_dir)
        return self.storage_reader.join_with_root_path(path_with_user_id)

    def _cut_user_id_from_entitynames(self, entities: list[str]):
        cut_entities = [self.path_cutter.remove_id_from_rel_path(entity) for entity in entities]
        return cut_entities

    def _get_all_entitynames_in_dir(self, rel_dir_path):
        entitynames = self.storage_reader.get_all_entitynames_in_dir(rel_dir_path)
        return self._cut_user_id_from_entitynames(entitynames)

    def get_list_of_entities(self, user_id, path_in_storage):
        try:
            self.path_ensurer.ensure_path_safety(user_id, path_in_storage)
            path_in_storage_with_id = self.path_joiner.join_paths(str(user_id), path_in_storage)
            entitynames = self._get_all_entitynames_in_dir(path_in_storage_with_id)
            return entitynames
        except EntityDoesNotExists:
            raise APIEntityDoesNotExists(path_in_storage)

        except HTTPException as e:
            raise e

        except Exception as e:
            self.logger.log(e)
from .router import storage_acting_routerfrom aiofiles.threadpool.utils import delegate_to_executor
from fastapi import APIRouter, Depends, Query

from .schemas.query import MakeDirInStorageQuery, DeleteEntityQuery
from .endpoint_handlers import MakeDirHandler, DeleteEntityHandler
from app.singletones import logger, storage_writer, path_joiner, path_ensurer
from app.routes.dependencies import auth_depend

storage_acting_router = APIRouter()

make_dir_handler = MakeDirHandler(logger, storage_writer, path_joiner, path_ensurer)
delete_entity_handler = DeleteEntityHandler(path_ensurer, storage_writer, path_joiner, logger)


@storage_acting_router.post('/make-dir-in-storage')
def make_dir_in_storage(user=Depends(auth_depend.auth), params: MakeDirInStorageQuery = Query()):
    make_dir_handler.make_dir_in_storage(user.id, params.path_in_storage, params.name)

@storage_acting_router.delete('/delete-entity-in-storage')
def delete_entity(user=Depends(auth_depend.auth), params: DeleteEntityQuery = Query()):
    auth_depend.ask_for_password(params.password, user)
    delete_entity_handler.delete_entity(str(user.id), params.path_in_storage)
from pydantic import BaseModel, Field


class MakeDirInStorageQuery(BaseModel):
    path_in_storage: str | None = None
    name: str = Field(max_length=255, min_length=1)

class DeleteEntityQuery(BaseModel):
    password: str
    path_in_storage: str
from interfaces import IStorageWriter
from exceptions import APIDirectoryAlreadyExists


class MakeDirHandler:
    def __init__(self, logger, storage_writer, path_joiner, path_ensurer):
        self.logger = logger
        self.storage_writer: IStorageWriter = storage_writer
        self.path_joiner = path_joiner
        self.path_ensurer = path_ensurer

    def make_dir_in_storage(self,user_id, path, name):
        if path is None:
            path = ''
        try:
            self.path_ensurer.ensure_path_safety(user_id, path)
            path_with_user_id = self.path_joiner.join_paths(str(user_id), path)
            self.storage_writer.create_dir(path_with_user_id, name)
        except FileExistsError:
            raise APIDirectoryAlreadyExistsfrom .make_dir_handler import MakeDirHandler
from .delete_dir_handler import DeleteEntityHandlerfrom interfaces import IStorageWriter
from exceptions import EntityDoesNotExists, APIEntityDoesNotExists


class DeleteEntityHandler:
    def __init__(self, path_ensurer, storage_writer, path_joiner, logger):
        self.path_ensurer = path_ensurer
        self.storage_writer: IStorageWriter = storage_writer
        self.path_joiner = path_joiner
        self.logger = logger

    def delete_entity(self, user_id, path_in_storage):
        try:
            if path_in_storage is None:
                path_in_storage = ''
            path_with_user_id = self.path_joiner.join_paths(user_id, path_in_storage)
            self.path_ensurer.ensure_path_safety(user_id, path_in_storage)
            self.storage_writer.delete_entity(path_with_user_id)
        except EntityDoesNotExists:
            raise APIEntityDoesNotExists(path_in_storage)
        except Exception as e:
            self.logger.log(e)from .router import auth_routerfrom fastapi import APIRouter, Request, Response, Query
from .endpoint_handlers import SignUpHandler, LogOutHandler, AuthHandler
from app.singletones import session_deleter, logger, user_reader, storage_writer, user_registrator, user_authenticator
from .schemas.query import AuthenticateQuery, SignUpQuery


auth_router = APIRouter()


logout_handler = LogOutHandler(session_deleter, logger)
sign_up_handler = SignUpHandler(user_registrator, storage_writer, user_reader)
auth_handler = AuthHandler(user_authenticator)


@auth_router.post('/log-out')
def log_out_endpoint(request: Request, response: Response):
    logout_handler.logout_user(request, response)


@auth_router.post('/sign-up')
def sign_up_endpoint(params: SignUpQuery = Query()):
    sign_up_handler.sign_up(params)
    return {"message": 'successfully signed up'}

@auth_router.post('/log-in')
def authenticate(response: Response, params: AuthenticateQuery = Query()):
    auth_handler.auth_with_psw_and_set_session_cookie(params.name, params.password, response)
    return {"message": 'successfully logged_in'}from pydantic import BaseModel, Field


class SignUpQuery(BaseModel):
    name: str = Field(max_length=16, min_length=1)
    password: str = Field(max_length=255)

class AuthenticateQuery(BaseModel):
    name: str
    password: strfrom fastapi import Response

from exceptions import APIIncorrectPassword, APIUserDontExists, IncorrectPassword, UserDontExists, APIUnauthorized, APISessionDontExists, APISessionExpired, SessionExpired, SessionDontExists
from config import SESSION_COOKIES_EXPIRE_TIME

class AuthHandler:
    def __init__(self, authenticator):
        self.authenticator = authenticator

    def set_session_id_cookie(self, session_id, response: Response):
        response.set_cookie(key="session_id", value=session_id, max_age=SESSION_COOKIES_EXPIRE_TIME,
                            samesite='lax', httponly=True)

    def check_password(self, password, user):
        self.authenticator.validate_user_and_password('', user, password)

    def auth_with_psw_and_set_session_cookie(self, name, password, response: Response):
        try:
            session_id = self.authenticator.make_session_by_name_and_psw(name, password)
            self.set_session_id_cookie(session_id, response)
        except IncorrectPassword:
            raise APIIncorrectPassword(password)
        except UserDontExists:
            raise APIUserDontExists(name)

    def auth_with_session_id(self, session_id):
        try:
            if session_id is None:
                raise APIUnauthorized
            return self.authenticator.auth_by_session_id(session_id)

        except SessionExpired:
            raise APISessionExpired
        except SessionDontExists:
            raise APISessionDontExists

from .auth_handler import AuthHandler
from .logout_handler import LogOutHandler
from .sign_up_handler import SignUpHandlerfrom fastapi import Request, Response


class LogOutHandler:
    def __init__(self, session_deleter, logger):
        self.session_deleter = session_deleter
        self.logger = logger

    def logout_user(self, request: Request, response: Response):
        try:
            session_id = request.cookies.get('session_id')
            if session_id is None:
                return
            response.delete_cookie('session_id')
            self.session_deleter.delete_session(session_id)
        except Exception as e:
            self.logger.log(e)
            raise e
from exceptions import APIUserAlreadyExists, UserAlreadyExists, APIUserStorageAlreadyExists
from interfaces import IStorageWriter

class SignUpHandler:
    def __init__(self, user_registrator, storage_writer, user_reader):
        self.user_registrator = user_registrator
        self.storage_writer: IStorageWriter = storage_writer
        self.user_reader = user_reader


    def sign_up(self, params):
        try:
            self.user_registrator.create_user(params.name, params.password)
            user = self.user_reader.get_by_kwargs(name = params.name)
            self.create_user_dir(user.id)
        except UserAlreadyExists:
            raise APIUserAlreadyExists(params.name)

    def create_user_dir(self, user_id):
        try:
            self.storage_writer.create_dir('', str(user_id), exist_ok=False)
        except FileExistsError:
            raise APIUserStorageAlreadyExistsfrom .router import upload_routerfrom fastapi import APIRouter, UploadFile, Query, Depends
from .schemas.query import UploadQuery
from .endpoint_handlers import UploadFileHandler
from app.singletones import storage_writer, path_ensurer, logger, path_joiner

from app.routes.dependencies import auth_depend

upload_router = APIRouter()

upload_handler = UploadFileHandler(storage_writer, path_ensurer, logger, path_joiner)

@upload_router.post('/upload-entity')
async def upload_entity_endpoint(files: list[UploadFile], params: UploadQuery = Query(), user=Depends(auth_depend.auth)):
    #TODO это дерьмо не работает
    # если пытатсься создать файл прямо в корне директории юзера, то пазлиб вместо ттго чтобы ОБЪЕДИНИТЬ ЭТИ ДВА ПУТИ возвращает имя файла как оно есть
    # Я ВООБЗЕ НЕ НЗАЮ ПОЧЕМУ ТАК Я НИКАК НЕ МЕНЯЛ ЛОГИКУ РАБОТЫ
    #


    await upload_handler.save_files_to_storage(str(user.id), params.path_in_storage, files)
    return {"message": 'successfully uploaded files'}
from pydantic import BaseModel


class UploadQuery(BaseModel):
    path_in_storage: str | None = None

class MakeDirInStorageQuery(BaseModel):
    path_in_storage: str | None = None
    name: str

from .upload_handler import UploadFileHandlerfrom exceptions import APIEntityDoesNotExists, APITooManyFiles
from interfaces import ILogger, IStorageWriter

class UploadFileHandler:
    def __init__(self, storage_writer, path_ensurer, logger, path_joiner):
        self.storage_writer: IStorageWriter = storage_writer
        self.path_ensurer = path_ensurer
        self.path_joiner = path_joiner
        self.logger: ILogger = logger
        self.max_upload_files = 20

    def create_rel_fpath_with_id(self, user_id, rel_path, fname:str):
        fname = fname.lstrip('/') #I DONT FUCKING KNOW WHY BUT PATHLIB REFUSES TO JOIN FUCKING PATHS/ IT JUST RETURNS FNAME AS IT WAS IF WE DONT REMOVE THIS SLASH
        print(fname)
        fpath_and_name = self.join_fpath_and_fname(rel_path, fname)
        fpath_and_name = fpath_and_name.lstrip('/') # THE SAME PROBLEM
        return self.path_joiner.join_paths(user_id, fpath_and_name)

    def join_fpath_and_fname(self, fpath, fname):
        return f'{fpath}/{fname}'

    async def _iterate_and_save_files_to_storage(self, files: list, output_path, user_id):
        try:
            for file in files:
                rel_fpath_with_id = self.create_rel_fpath_with_id(user_id, output_path, file.filename)
                print(rel_fpath_with_id)
                await self.storage_writer.async_write_from_fastapi_uploadfile_to_file(file, rel_fpath_with_id)
        except FileNotFoundError:
            raise APIEntityDoesNotExists(output_path)
        except Exception as e:
            self.logger.log(e)
            raise e

    async def save_files_to_storage(self, user_id, path_in_storage, files: list):
        if len(files) > self.max_upload_files:
            raise APITooManyFiles
        if path_in_storage is None:
            path_in_storage = ''
        self.path_ensurer.ensure_path_safety(user_id, path_in_storage)
        await self._iterate_and_save_files_to_storage(files, path_in_storage, str(user_id))

from app.routes.authorization.router import auth_handler
from depends import AuthDepend

auth_depend = AuthDepend(auth_handler)
from redis import Redis

from utils import Logger, TimeHandler, PathCutter, PathJoiner, PathValidEnsurer, Hasher
from logic import StorageReader, StorageWriter, Archivator
from db_repository import ModelReader, ModelActor
from auth import UserRegistration, UserAuthentication ,SessionValidator, SessionMaker, SessionDeleter, UserGetter
from cache_handler import RedisCacher
from alchemy import User, Session

from config import STORAGE_PATH, CACHE_EXPIRE_TIME, CACHE_HOST, CACHE_PORT, SESSION_EXPIRE_TIME

logger = Logger()
redis_client = Redis(host=CACHE_HOST, port=CACHE_PORT, decode_responses=True)
path_joiner = PathJoiner(STORAGE_PATH)
path_cutter = PathCutter(STORAGE_PATH)
path_ensurer = PathValidEnsurer(STORAGE_PATH, path_cutter, path_joiner)
archivator = Archivator()
time_handler = TimeHandler()
storage_reader = StorageReader(STORAGE_PATH, path_joiner, path_cutter)
storage_writer = StorageWriter(STORAGE_PATH)
hasher = Hasher()
redis_cacher = RedisCacher(redis_client, CACHE_EXPIRE_TIME)
user_reader = ModelReader(User, logger)
user_actor = ModelActor(User, logger)
session_reader = ModelReader(Session, logger)
session_actor = ModelActor(Session, logger)
session_validator = SessionValidator(time_handler)
session_maker = SessionMaker(int(SESSION_EXPIRE_TIME), session_actor, time_handler, hasher, redis_cacher)
user_getter = UserGetter(user_reader, session_reader, redis_cacher, session_validator)
user_registrator = UserRegistration(user_actor, hasher, logger)
user_authenticator = UserAuthentication(user_reader, session_maker, user_getter, logger, hasher)
session_deleter = SessionDeleter(redis_cacher, session_actor)from fastapi import FastAPI
from .routes import download_router, auth_router, upload_router ,storage_acting_router ,view_storage_router

app = FastAPI()

app.include_router(view_storage_router)
app.include_router(storage_acting_router)
app.include_router(download_router)
app.include_router(upload_router)
app.include_router(auth_router)from datetime import datetime


print(datetime.astimezone())from werkzeug.security import generate_password_hash, check_password_hash
from secrets import token_urlsafe

class Hasher:

    def generate_psw_hash(self, password):
        return generate_password_hash(password)

    def check_password(self, password, hashed_psw):
        return check_password_hash(hashed_psw, password)

    def create_session_id_hash(self):
        return token_urlsafe(32)
from .path_validator import PathValidEnsurer
from .path_creator import PathJoiner
from .logger import Logger
from .text_encoding import get_encoded_string
from .path_cutter import PathCutter
from .time_handler import TimeHandler
from .hasher import Hasherfrom exceptions import NotAUserId

class PathCutter:
    def __init__(self, root_path):
        self.root_path = root_path

    def cut_path(self, path:str, cutting_part):
        return path.removeprefix(cutting_part)

    def get_user_id_from_abs_path(self, abs_path: str):
        path = abs_path.removeprefix(self.root_path)
        id = self.get_user_id_part_from_rel_path(path)
        if not id.isdigit():
            raise NotAUserId(abs_path)
        return id

    def get_user_id_part_from_rel_path(self, path:str) -> str:
        #path must look like '/<id>/some/path or '<id>/some/path
        if path[0] == '/':
            return path.split('/')[1]
        return path.split('/')[0]

    def remove_id_from_rel_path(self, rel_path):
        if rel_path[0] == '/':
            return rel_path[2:]
        return rel_path[1:]

from urllib.parse import quote


def get_encoded_string(string):
    return quote(string)

from pathlib import Path


class PathJoiner:
    def __init__(self, root_path):
        self.root_path = root_path


    @property
    def root(self):
        return self.root_path


    def join_paths(self, path1, path2):
        new_path = Path(path1, path2)
        return new_path.__str__()

    def join_with_root_path(self, path:str | int):
        if isinstance(path, int):
            path = str(path)
        return self.join_paths(self.root_path, path)

    def create_absolute_path(self, user_id, entity_path_in_storage):
        if entity_path_in_storage is None:
            entity_path_in_storage = ''
        user_id = str(user_id)
        abs_user_dir_path = self.create_absolute_user_dir_path(user_id)
        abs_path = self.join_paths(abs_user_dir_path, entity_path_in_storage)
        return abs_path

    def create_absolute_user_dir_path(self, user_id):
        user_id = str(user_id)
        return self.join_with_root_path(user_id)from datetime import datetime, timedelta

class TimeHandler:
    def add_days_to_current_date(self, days):
        time_delta = timedelta(days=days)
        now = datetime.today()
        new_date = now + time_delta
        return new_date

    def is_date_future(self, date):
        return datetime.now().date() < date

    def get_today_date(self):
        return datetime.today()

    def get_str_today_date(self):
        return self.get_today_date().strftime('%d/%m/%Y')class Logger:

    def __init__(self):
        self.red_log = "\033[1;31mLOG\033[0m"

    def log(self, exception):
        print(f'{self.red_log}{exception}{self.red_log}')

    def decor_log(self, func):
        def wrapper(*args, **kwargs):
            try:
                result = func(*args, **kwargs)
                return result
            except Exception as e:
                Logger.log(e)
        return wrapper
from exceptions import APIPathGoesBeyondLimits
from path_explorator import PathGoesBeyondLimits, EntityDoesNotExists
from interfaces import IPathCutter
from pathlib import Path


class PathValidEnsurer:

    def __init__(self, root_dir, path_cutter, path_creator):
        self.path_cutter: IPathCutter = path_cutter
        self.path_creator = path_creator
        self.root_dir = root_dir

    def does_contain_uplinks(self, path:str | Path):
        path = Path(self.root_dir, path)
        if ('..', '.', './') in path.parts:
            return True
        return False

    def does_contain_symlinks_and_uplinks(self, path:str):
        path = Path(self.root_dir, path)
        if path.is_symlink() and self.does_contain_uplinks(path):
            return True
        return False


    def is_goes_beyond_limits(self, requesting_path: str | None):
        return not self.is_path_rel_to_another_path(requesting_path, self.root_dir.__str__())


    def is_path_rel_to_another_path(self, path: str | None, relative_to_path: str | None):
        if path is None:
            path = ''
        if relative_to_path is None:
            relative_to_path = ''
        path = Path(path).resolve()
        relative_to_path = Path(relative_to_path)
        if path.is_relative_to(relative_to_path):
           return True
        return False

    @property
    def root(self):
        return self.root_dir.__str__()

    def is_exists(self, path: str) -> bool:
        """
        Checks if specified path exists
        :param path: path to the entity checking
        :return: exists or not True or False
        """
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.exists()


    def is_file(self, path: str) -> bool:
        """
        Checks if specified entity is FILE
        :param path: path to entity
        :return: file or not
        """
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.is_file()


    def is_dir(self, path: str) -> bool:
        """
        Checks if specified entity is DIRECTORY/FOLDER
        :param path: path to entity
        :return: dir or not
        """
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.is_dir()


    def raise_if_goes_beyond_limits(self, abs_path: str, user_id, requesting_path:str):
        user_directory = self.path_creator.create_absolute_user_dir_path(user_id)
        if self.is_goes_beyond_limits(abs_path):
            raise PathGoesBeyondLimits(requesting_path)
        if not self.is_path_rel_to_another_path(abs_path, user_directory):
            raise PathGoesBeyondLimits(requesting_path)

    def raise_if_entity_dont_exists(self, path:str):
        if not self.is_exists(path):
            raise EntityDoesNotExists(path)

    def ensure_path_safety(self, user_id: int, path_in_storage: str):
        try:
            abs_path = self.path_creator.create_absolute_path(user_id, path_in_storage)
            self.raise_if_goes_beyond_limits(abs_path, user_id, path_in_storage)
        except PathGoesBeyondLimits:
            raise APIPathGoesBeyondLimits(path_in_storage)


from .models import User, Sessionfrom sqlalchemy import Column, Integer, String, Boolean, create_engine, Date, ForeignKey
from sqlalchemy.orm import declarative_base

from config import DATABASE_URL

engine = create_engine(DATABASE_URL)


Base = declarative_base()


class User(Base):

    __tablename__ = "users"

    id = Column(Integer, primary_key=True, autoincrement=True)
    password = Column(String(255))
    name = Column(String(30), unique=True)
    is_admin = Column(Boolean, default=False)
    owning_dir_id = Column(Integer, unique=True)

class Session(Base):
    __tablename__ = "sessions"

    id = Column(String(50), primary_key=True)
    user_id = Column(Integer, ForeignKey(User.id))
    expire_date = Column(Date)

Base.metadata.create_all(bind=engine)

from pathlib import Path
from exceptions import EntityDoesNotExists, EntityIsNotADir


class StorageReader:
    def __init__(self, root_dir_abs_path: str, path_creator, path_cutter):
        self.root_dir = self.__init_root_dir(root_dir_abs_path)
        self._path_creator = path_creator
        self._path_cutter = path_cutter

    def __init_root_dir(self, root_dir_abs_path: str):
        if not isinstance(root_dir_abs_path, str):
            raise TypeError(f'root_dir_abs_path type must be str, not {type(root_dir_abs_path)}')
        root_dir = Path(root_dir_abs_path)

        if not root_dir.exists():
            raise EntityDoesNotExists(root_dir)

        return root_dir

    @property
    def root_path(self):
        return self.root_dir.__str__()

    def join_with_root_path(self, path: str):
        joined = self.root_dir.joinpath(Path(path)).__str__()
        return joined

    def get_all_filenames_in_dir(self, dirpath: str | None):
        """
        Returns names of all FILES in directory
        :param dirpath: directory getting files from
        :return: List of all files (strings) in specified directory
        """
        if dirpath is None:
            dirpath = ''
        if not isinstance(dirpath, str):
            raise TypeError(f'dirpath arg must be str, not {type(dirpath)}')
        path = Path(self.root_dir, dirpath)
        if not path.exists():
            raise EntityDoesNotExists(dirpath)
        if not path.is_dir():
            raise EntityIsNotADir(dirpath)
        filenames = [self._path_cutter.cut_path(str(fname), str(self.root_dir)) for fname in path.iterdir() if fname.is_file()]
        return filenames

    def get_all_entitynames_in_dir(self, dirpath: str | None):
        """
        Returns all ENTITIES names (entity = any file, folder)
        :param dirpath: directory getting entities from
        :return: list of all entities names (strings) in specified directory
        """
        if dirpath is None:
            dirpath = ''
        if not isinstance(dirpath, str):
            raise TypeError(f'dirpath arg must be str, not {type(dirpath)}')
        path = Path(self.root_dir, dirpath)
        print(path.__str__(), 'PATH')
        if not path.exists():
            raise EntityDoesNotExists(dirpath)
        if not path.is_dir():
            raise EntityIsNotADir(dirpath)
        entities_names = [self._path_cutter.cut_path(str(entity), str(self.root_dir)) for entity in path.iterdir()]
        return entities_names

    def find_entities_path(self, searching_in: str | None, pattern: str) -> list[str]:
        """
        Return list with paths of entity or entities that match a given pattern
        :param searching_in: path to directory in which to find
        :param pattern: pattern of entity name you need to find (example "fname.txt", "*.txt")
        :return: List with absolute paths (Path objects) or None
        """
        if searching_in is None:
            searching_in = ''
        if not isinstance(searching_in, str):
            raise TypeError(f'searching_in arg must be str, not {type(searching_in)}')
        if not isinstance(pattern, str):
            raise TypeError(f'pattern arg must be str, not {type(pattern)}')
        searchable_dir = Path(self.root_dir, searching_in)
        paths = [self._path_cutter.cut_path(str(path), str(self.root_dir)) for path in searchable_dir.rglob(pattern)]
        return paths

    def is_exists(self, path: str | None) -> bool:
        """
        Checks if specified path exists
        :param path: path to the entity checking
        :return: exists or not True or False
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.exists()

    def is_file(self, path: str | None) -> bool:
        """
        Checks if specified entity is FILE
        :param path: path to entity
        :return: file or not
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.is_file()

    def is_dir(self, path: str | None) -> bool:
        """
        Checks if specified entity is DIRECTORY/FOLDER
        :param path: path to entity
        :return: dir or not
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.is_dir()

    def get_name(self, path: str | None) -> str:
        """
        Get name of entity from strlike path
        :param path: strlike path
        :return: str name of entity (example /home/user/hello.txt  will return hello.txt)
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity_path = Path(self.root_dir, path)
        return entity_path.name



from .storage_reader import StorageReader
from .archivator import Archivator
from .storage_writer import StorageWriterimport shutil

from aiofiles import open as aio_open
from pathlib import Path
from exceptions.path_exc import EntityDoesNotExists


class StorageWriter:
    def __init__(self, root_dir_abs_path: str):
        if not isinstance(root_dir_abs_path, str):
            raise TypeError(f'root_dir_abs_path argument must be str, not {type(root_dir_abs_path)}')
        self.root_dir = Path(root_dir_abs_path)

    def delete_entity(self, path: str | None):
        entity = Path(self.root_dir, path)
        if entity.exists():
            if entity.is_dir():
                shutil.rmtree(entity)
            elif entity.is_file():
                entity.unlink()
        else:
            raise EntityDoesNotExists(path)


    def create_dir(self, path: str | None, name:str, exist_ok=True):
        """
        Creates directory/folder in specified path with specified name
        :param path: Path to the location of the future directory.
        The path must be relative to the root directory, which is passed as an argument to __init__ as root_dir_abs_path.
        This rule is used in every object where root_dir_abs_path is passed during initialization.
        you can set path param as empty string if you need to make dir in root_ dir
        :param name: name of dir
        :return: None
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path argument must be str, not {type(path)}')
        if not isinstance(name, str):
            raise TypeError(f'name argument must be str, not {type(path)}')
        root_dir = Path(self.root_dir, path, name)
        root_dir.mkdir(exist_ok=exist_ok)

    def create_file(self, path: str | None , name: str, exist_ok):
        """
        Create file in specified path with specified name
        :param path: Path to the location of the future file.
        The path must be relative to the root directory, which is passed as an argument to __init__ as root_dir_abs_path.
        This rule is used in every object where root_dir_abs_path is passed during initialization.
        you can set path param as empty string if you need to make file in root_ dir
        :param name: name of file
        :return: None
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path argument must be str, not {type(path)}')
        if not isinstance(name, str):
            raise TypeError(f'name argument must be str, not {type(path)}')
        path_to_future_file = Path(self.root_dir, path, name)
        path_to_future_file.touch(exist_ok=exist_ok)

    async def async_write_from_fastapi_uploadfile_to_file(self, source_file, output_file_path, exist_ok=True):
        """
        special method for fastapi uploading file to hard disk
        :param source_file: fastapi UploadFile object
        :param output_file_path: path where an actual file will be saved on hard disk
        :return: None
        """
        output_file_path = Path(self.root_dir, output_file_path)
        async with aio_open(output_file_path, 'wb') as output_file:
            while content := await source_file.read(1024):
                await output_file.write(content)from pathlib import Path
from tempfile import mkdtemp
from zipfile import ZipFile, ZIP_DEFLATED


class Archivator:
    def __init__(self):
        self._zip_path = None
        self.tmp_dir = Path(mkdtemp())

    def has_zip_path(self):
        return self._zip_path is not None

    def make_zip_in_tmp_dir(self, archivable_dir):
        return self.tmp_dir / f"{archivable_dir.name}.zip"

    def write_from_dir_to_zip(self, dir, zip):
        with ZipFile(zip, mode='w', compression=ZIP_DEFLATED, allowZip64=True, compresslevel=6) as zipf:
            for file_path in dir.rglob('*'):
                if file_path.is_file():
                    entity = file_path.relative_to(dir)
                    zipf.write(file_path, entity)

    def cleanup_temp_files(self):
        if self.has_zip_path():
            self._cleanup()
            self._zip_path = None

    def _cleanup(self):
        self._zip_path.unlink(missing_ok=True)

    def create_large_zip(self, archivable_dir_path: str) -> Path:
        archivable_dir = Path(archivable_dir_path)
        self._zip_path = self.make_zip_in_tmp_dir(archivable_dir)
        self.write_from_dir_to_zip(archivable_dir, self._zip_path)
        return self._zip_path
