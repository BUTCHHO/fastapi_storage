class NotAUserId(Exception):
    def __init__(self, path:str):
        msg = f'path {path} dont starts with user_id. Must look like \'1/folder/file.txt\''
        super().__init__(msg)from fastapi import HTTPException


class APITooManyFiles(HTTPException):
    def __init__(self):
        detail = {"message": 'Too many files were uploaded at once. Please try again with fewer files per upload.',
                  "code": 'too_many_files'}
        status_code = 429
        super().__init__(detail, status_code)from .path_http_exc import APIPathGoesBeyondLimits, APIUserStorageAlreadyExists, APIDirectoryAlreadyExists, APIEntityDoesNotExists, APIUnsupportedEntityType
from .exc import NotAUserId
from .path_exc import EntityDoesNotExists, EntityIsNotADir, PathGoesBeyondLimits
from .auth_http_exc import APIUserAlreadyExists, APIUserDontExists, APIIncorrectPassword, APISessionDontExists, APISessionExpired, APIUnauthorized
from .config_exc import StoragePathIsNone, DatabaseUrlIsNone, CacheHostIsNone, CachePortIsNone, CacheExpireTimeIsNone, SessionMakerKeyIsNone
from .http_files_exc import APITooManyFilesclass StoragePathIsNone(Exception):
    def __init__(self):
        msg = 'STORAGE_PATH value from .env file is None. Must be filled'
        super().__init__(msg)

class DatabaseUrlIsNone(Exception):
    def __init__(self):
        msg = 'DATABASE_URL value from .env file is None. Must be filled'
        super().__init__(msg)

class CachePortIsNone(Exception):
    def __init__(self):
        msg = 'CACHE_PORT value from .env file is None. Must be filled'
        super().__init__(msg)

class CacheHostIsNone(Exception):
    def __init__(self):
        msg = 'CACHE_HOST value from .env file is None. Must be filled'
        super().__init__(msg)

class CacheExpireTimeIsNone(Exception):
    def __init__(self):
        msg = 'CACHE_EXPIRE_TIME value from .env file is None. Must be filled'
        super().__init__(msg)

class SessionMakerKeyIsNone(Exception):
    def __init__(self):
        msg = 'SESSION_MAKER_KEY value from .env file is None. Must be filled'
        super().__init__(msg)from fastapi.exceptions import HTTPException


class APIUserAlreadyExists(HTTPException):
    def __init__(self, name, detail=None, status_code=409):
        if not detail:
            detail = {"message": f'User with name {name} already exists', "code": 'user_already_exists'}
        super().__init__(status_code, detail)

class APIUserDontExists(HTTPException):
    def __init__(self, name=None):
        detail = {"message": f'User with name {name} dont exists', "code": 'user_dont_exists'}
        status_code = 404
        super().__init__(status_code, detail)

class APIIncorrectPassword(HTTPException):
    def __init__(self, detail=None, status_code=401):
        if not detail:
            detail = {"message": f'Incorrect password', "code": 'incorrect_password'}
        super().__init__(status_code, detail)

class APISessionDontExists(HTTPException):
    def __init__(self, detail=None, status_code=404):
        if not detail:
            detail = {"message": f'Session dont exists', "code": 'session_dont_exists'}
        super().__init__(status_code, detail)

class APISessionExpired(HTTPException):
    def __init__(self):
        detail = {"message": f'Session expired', "code": 'session_expired'}
        status_code = 440
        super().__init__(status_code, detail)

class APIUnauthorized(HTTPException):
    def __init__(self):
        detail = {"message": f'you have to log in to see this page', "code": 'unauthorized'}
        status_code = 401
        super().__init__(status_code, detail)class FieldUniqueViolation(Exception):
    def __init__(self, **kwargs):
        msg = f'Record with kwargs {kwargs} is violating unique flag'
        super().__init__(msg)

from fastapi import HTTPException

class APIPathGoesBeyondLimits(HTTPException):
    def __init__(self, path_in_storage, detail=None, status_code=403):
        if not detail:
            detail = {"message": f'path {path_in_storage} is goes beyond limits', "code": 'path_goes_beyond_limits'}
        super().__init__(status_code=status_code, detail=detail)

class APIEntityDoesNotExists(HTTPException):
    def __init__(self, path_in_storage):
        detail = {"message": f'entity at {path_in_storage} does not exists', "code": 'entity_does_not_exists'}
        status_code = 404
        super().__init__(status_code=status_code, detail=detail)

class APIUnsupportedEntityType(HTTPException):
    def __init__(self, entity_path_in_storage, detail=None, status_code=415):
        if not detail:
            detail = {"message":f'unsupported entity type {entity_path_in_storage}', "code":'unsupported_entity_type'}
        super().__init__(status_code, detail)

class APIUserStorageAlreadyExists(HTTPException):
    def __init__(self):
        status_code=409
        detail = {"message": 'Storage for this user already exists. Failed to create new storage', "code": 'user_storage_already_exists'}
        super().__init__(status_code, detail)

class APIDirectoryAlreadyExists(HTTPException):
    def __init__(self, path):
        status_code = 409
        detail = {"message": f'Directory at {path} already exists', "code":'diractory_already_exists'}
        super().__init__(status_code, detail)

from path_explorator.exceptions import EntityDoesNotExists, EntityIsNotADir, PathGoesBeyondLimitsfrom http.client import responses

from fastapi import UploadFile
from fastapi.testclient import TestClient


from main import app
client = TestClient(app)

def test_sign_in():
    params = {'name': 'tester1', 'password': '123'}
    response = client.post('/log-in', params=params)
    assert response.status_code == 200

def test_view_root_storage():
    url = '/storage'
    params = {"user_id": 1}
    response = client.get(url=url, params=params)
    json = response.json()
    assert response.status_code == 200
    assert 'entities' in json

def test_view_storage():
    url = '/storage/music%2Fletov?user_id=1'
    params = {"user_id": 1}
    response = client.get(url=url, params=params)
    assert  response.status_code == 200
    assert 'entities' in response.json()

def test_download_dir():
    url = '/download-entity'
    params = {"user_id": 1, "entity_path_in_storage": 'music/nirvana'}
    response = client.get(url=url, params=params)
    headers = response.headers
    content_len = int(headers['content-length'])
    assert response.status_code == 200
    assert content_len > 0

def test_download_file():
    url = '/download-entity'
    params = {"user_id": 1, "entity_path_in_storage": 'images/Desert.jpg'}
    response = client.get(url=url, params=params)
    headers = response.headers
    content_len = int(headers['content-length'])
    status_code = response.status_code
    assert status_code == 200
    assert content_len > 0

def test_upload_entity():
    print('not_impl')from unittest import TestCase
from unittest.mock import patch


class TestPathValidEnsurer(TestCase):
    def setUp(self):
        pass


    def test_raise_if_goes_beyond_limits(self):from logic import Archivator
from config import STORAGE_PATH

archiver = Archivator()

def test_create_large_zip():
    path_to_archivable = f"{STORAGE_PATH}/music"
    zip = archiver.create_large_zip(path_to_archivable)
    zip_name = zip.name
    expected_zip_name = 'music.zip'
    assert zip_name == expected_zip_name
    archiver.cleanup_temp_files()

from unittest import TestCase
from unittest.mock import patch, MagicMock
from utils import PathJoiner


class TestPathCreator(TestCase):
    def setUp(self):
        self.root = '/root/path'
        self.path_joiner = PathJoiner(self.root)

    def test_join_paths(self):
        first_part = 'directory/dir/'
        second_part = 'path/to/dir'
        result = self.path_joiner.join_paths(first_part, second_part)
        expected_result = f'{first_part}{second_part}'
        self.assertEqual(result, expected_result)

    def test_join_with_root_path(self):
        path = 'path/to/dir'
        expected = f'{self.root}/{path}'
        result = self.path_joiner.join_with_root_path(path)
        self.assertEqual(result, expected)

    def test_create_absolute_entity_path(self):
        storage_id = 'rerer'
        path_in_storage = 'path/to/dir'
        expected = f'{self.root}/{storage_id}/{path_in_storage}'
        result = self.path_joiner.create_absolute_entity_path(storage_id, path_in_storage)
        self.assertEqual(result, expected)
from .auth import AuthDependfrom fastapi import Request

from exceptions import APIUserDontExists
from exceptions.auth_http_exc import APIIncorrectPassword
from auth.exceptions import IncorrectPassword, UserDontExists
from exceptions.auth_http_exc import APIUnauthorized

class AuthDepend:
    def __init__(self, auth_handler):
        self.auth_handler = auth_handler

    def auth_allow_unauthorized(self, request: Request):
        try:
            return self.auth(request)
        except APIUserDontExists:
            return None
        except APIUnauthorized:
            return None

    def auth(self, request: Request):
        session_id = request.cookies.get('session_id')
        return self.auth_handler.auth_with_session_id(session_id)

    def ask_for_password(self, password, user):
        try:
            self.auth_handler.check_password(password, user)
        except IncorrectPassword:
            raise APIIncorrectPassword
        except UserDontExists:
            raise APIUserDontExists('')
from dotenv import load_dotenv
from os import getenv

load_dotenv('.env')

STORAGE_PATH = getenv('STORAGE_PATH')
DATABASE_URL = getenv('DATABASE_URL')
SESSION_EXPIRE_TIME = getenv('SESSION_EXPIRE_TIME_DAYS')
SESSION_COOKIES_EXPIRE_TIME = getenv('SESSION_COOKIES_EXPIRE_TIME_SECONDS')
CACHE_HOST = getenv('CACHE_HOST')
CACHE_PORT = int(getenv('CACHE_PORT'))
CACHE_EXPIRE_TIME = getenv('CACHE_EXPIRE_TIME_SECONDS')


assert STORAGE_PATH is not None
assert DATABASE_URL is not None
assert SESSION_EXPIRE_TIME is not None
assert SESSION_COOKIES_EXPIRE_TIME is not None
assert CACHE_PORT is not None
assert CACHE_HOST is not None
assert CACHE_EXPIRE_TIME is not None
from .reader import ModelReader
from .actor import ModelActorfrom sqlalchemy.exc import IntegrityError
from psycopg2.errors import UniqueViolation
from exceptions.database_repo import FieldUniqueViolation

from .parent_access import ParentAccess

class ModelActor(ParentAccess):
    def __init__(self, model, logger):
        super().__init__(model, logger)

    def create_and_write_record_to_db(self, **kwargs):
        record = self.create_record(**kwargs)
        self.write_record_to_db(record)





    def write_record_to_db(self, record):
            session = self.session()
            try:
                session.add(record)
                session.commit()
            except IntegrityError as integrity_error:
                if isinstance(integrity_error.orig, UniqueViolation):
                    raise FieldUniqueViolation()
                raise
            except Exception as e:
                session.rollback()
                self.logger.log(e)
            finally:
                session.close()


    def create_record(self, **kwargs):
        try:
            return self.model(**kwargs)
        except Exception as e:
            self.logger.log(e)
            raise

    def delete_record_by_id(self, id):
        session = self.session()
        try:
            session.query(self.model).filter_by(id=id).delete()
            session.commit()
        except Exception as e:
            self.logger.log(e)
            session.rollback()
        finally:
            session.close()

    def delete_record_by_kwargs(self, **kwargs):
        session = self.session()
        try:
            session.query(self.model).filter_by(**kwargs).delete()
            session.commit()
        except Exception as e:
            self.logger.log(e)
            session.rollback()
        finally:
            session.close()from sqlalchemy.orm import sessionmaker
from alchemy.models import engine

class ParentAccess:
    def __init__(self, model, logger):
        self.session = sessionmaker(engine)
        self.model = model
        self.logger = loggerfrom sqlalchemy.orm import Session

from .parent_access import ParentAccess

class ModelReader(ParentAccess):
    def __init__(self, model, logger):
        super().__init__(model, logger)

    def get_by_id(self, id):
        session = self.session()
        try:
            return session.query(self.model).filter_by(id=id).first()
        except Exception as e:
            self.logger.log(e)
        finally:
            session.close()

    def get_by_kwargs(self, **kwargs):
        session = self.session()
        try:
             return session.query(self.model).filter_by(**kwargs).first()
        except Exception as e:
            self.logger.log(e)
        finally:
            session.close()

    def does_record_with_id_exists(self, id):
        session: Session = self.session()
        try:
            return session.query(self.model).filter_by(id=id).exists()
        except Exception as e:
            self.logger.log(e)
        finally:
            session.close()

    def does_record_with_kwargs_exists(self, **kwargs):
        session = self.session()
        try:
            return session.query(self.model).filter_by(**kwargs).exists()
        except Exception as e:
            self.logger.log(e)
        finally:
            session.close()from .interfaces import IArchivator, IPathValidator, IStorageReader, IStorageWriter, ILogger, IPathJoiner, IPathCutter, IModelReader, IModelActor, ITimeHandlerfrom typing import Callable
from abc import ABC, abstractmethod

class IStorageReader(ABC):
    @abstractmethod
    def get_name(self,path:str) -> str: pass
    @abstractmethod
    def is_dir(self, path:str) -> bool: pass
    @abstractmethod
    def is_file(self, path:str) -> bool: pass
    @abstractmethod
    def join_with_root_path(self, path:str) -> str: pass
    @abstractmethod
    def get_all_entitynames_in_dir(self, path: str) -> list[str]: pass
    @abstractmethod
    def find_entities_path(self, searching_in: str | None, pattern: str) -> list[str]: pass

class IStorageWriter(ABC):
    @abstractmethod
    async def async_write_from_fastapi_uploadfile_to_file(self, source_file, output_file_path:str) -> None: pass
    @abstractmethod
    def create_dir(self, path: str, name: str, exist_ok=True): pass
    @abstractmethod
    def create_file(self, path: str, name: str, exist_ok=True): pass
    @abstractmethod
    def delete_entity(self, path: str | None) -> None: pass

class IArchivator(ABC):
    @abstractmethod
    def create_large_zip(self, path: str) -> str: pass

class IPathValidator(ABC):
    @abstractmethod
    def raise_if_path_invalid(self, path:str) -> None: pass
    @abstractmethod
    def raise_if_goes_beyond_limits(self, path:str) -> None: pass
    @abstractmethod
    def is_goes_beyond_limits(self, path:str) -> bool: pass
    @abstractmethod
    def is_exists(self, path:str) -> bool: pass

class IPathJoiner(ABC):
    @abstractmethod
    def join_paths(self, path1: str, path2: str) -> str: pass

class ILogger(ABC):
    @abstractmethod
    def log(self, exception) -> None: pass
    @abstractmethod
    def decor_log(self, func) -> Callable: pass

class IPathCutter(ABC):
    @abstractmethod
    def get_user_id_from_rel_path(self, path:str) -> str: pass
    @abstractmethod
    def get_user_id_from_abs_path(self, path: str) -> str: pass
    @abstractmethod
    def remove_id_from_rel_path(self, path: str) -> str: pass
class IModelReader(ABC):
    @abstractmethod
    def get_by_id(self, id: int): pass
    @abstractmethod
    def get_by_kwargs(self, **kwargs): pass
    @abstractmethod
    def does_record_with_kwargs_exists(self, **kwargs) -> bool: pass


class IModelActor(ABC):
    @abstractmethod
    def create_and_write_record_to_db(self, **kwargs): pass
    @abstractmethod
    def create_record(self, **kwargs): pass
    @abstractmethod
    def write_record_to_db(self, record): pass
    @abstractmethod
    def delete_record_by_kwargs(self, **kwargs): pass
    @abstractmethod
    def delete_record_by_id(self, id): pass

class ITimeHandler(ABC):
    @abstractmethod
    def is_date_future(self, date) -> bool: pass
    @abstractmethod
    def add_days_to_current_date(self, days) -> object: pass
    @abstractmethod
    def get_today_date(self) -> object: pass
    @abstractmethod
    def get_str_today_date(self) -> str: passfrom .cache_handler import MemCacher, RedisCacher
class Cacher:
    def __init__(self, client, expire_time):
        self.client = client
        self.expire_time = expire_time

    def get_data(self, key):
        raise NotImplementedError

    def put_data(self, key, value):
        raise NotImplementedError

    def delete_data(self, key):
        raise NotImplementedError

class MemCacher(Cacher):
    def __init__(self, memcache_client, data_expire_time):
        super().__init__(memcache_client, data_expire_time)

    def get_data(self, key):
        return self.client.get(key)

    def put_data(self, key, value):
        self.client.add(key, value, self.expire_time)

    def delete_data(self, key):
        self.client.delete(key)

class RedisCacher(Cacher):
    def __init__(self, redis_client, data_expire_time):
        super().__init__(redis_client, data_expire_time)

    def get_data(self, key):
        return self.client.get(key)

    def put_data(self, key, value):
        self.client.set(key, value, ex=self.expire_time, nx=True)

    def delete_data(self, key):
        self.client.delete(key)

    def is_data_exists(self, key):
        return self.client.exists(key)from interfaces import IModelActor


class UserDeleter:
    def __init__(self, user_actor):
        self.user_actor: IModelActor = user_actor

    def delete_user_by_id(self, user_id):
        #make sure to delete session_id from user's cookies and from db
        self.user_actor.delete_record_by_id(user_id)from auth.exceptions import SessionDontExists, SessionExpired


class SessionGetter:
    def __init__(self, session_reader, cacher, session_validator, session_deleter):
        self.session_reader = session_reader
        self.cacher = cacher
        self.session_validator = session_validator
        self.session_deleter = session_deleter

    def get_session_from_db(self, user_id):
        return self.session_reader.get_by_kwargs(user_id=user_id)

    def get_session_id_by_user_id(self, user_id):
        session = self.get_session_from_db(user_id)
        if session is None:
            raise SessionDontExists
        try:
            self.session_validator.validate_session_or_raise(session)
        except SessionExpired:
            self.session_deleter.delete_session(session)
            raise
        return session
from interfaces import IModelActor
from interfaces import IModelReader

class SessionDeleter:
    def __init__(self, cacher, session_actor, session_reader):
        self.cacher = cacher
        self.session_actor: IModelActor = session_actor
        self.session_reader: IModelReader = session_reader

    def delete_session_by_user_id(self, user_id:str):
        session = self.session_reader.get_by_kwargs(user_id=user_id)
        self.delete_session(session.id)

    def delete_session(self, session_id):
        """
        MAKE SURE YOU DELETE SESSION_ID FROM USER COOKIES!!!
        :param session_id:
        :return:
        """
        self.cacher.delete_data(session_id)
        self.session_actor.delete_record_by_id(session_id)from .session_maker import SessionMaker
from .user_getter import UserGetter
from .registration import UserRegistration
from .session_validator import SessionValidator
from .authentication import UserAuthentication
from .session_deleter import SessionDeleter
from .logout_user import UserLogout
from .session_getter import SessionGetterfrom .exceptions import SessionDontExists


class UserGetter:
    def __init__(self, user_reader, session_reader, cacher, session_validator):
        self.session_reader = session_reader
        self.user_reader = user_reader
        self.cacher = cacher
        self.session_validator = session_validator


    def _get_user_from_db(self, user_id):
        return self.user_reader.get_by_kwargs(id=user_id)

    def _get_session_from_db(self, id):
        return self.session_reader.get_by_id(id)

    def _get_user_if_session_not_in_cache(self, session_id):
        session = self._get_session_from_db(session_id)
        if not session:
            raise SessionDontExists
        self.session_validator.validate_session_or_raise(session)
        return self._get_user_from_db(session.user_id)

    def get_user_by_session_id(self, session_id):
        user_id = (self.cacher.get_data(session_id))
        if not user_id:
            return self._get_user_if_session_not_in_cache(session_id)
        user_id = int(user_id)
        user = self._get_user_from_db(user_id)
        return user
from interfaces import ITimeHandler
from .exceptions import SessionExpired

class SessionValidator:
    def __init__(self, time_handler, session_deleter):
        self.time_handler: ITimeHandler = time_handler
        self.session_deleter = session_deleter

    def is_session_expired(self, session_expire_date):
        if self.time_handler.is_date_future(session_expire_date):
            return False
        return True

    def validate_session_or_raise(self, session):
        if self.is_session_expired(session.expire_date):
            self.session_deleter.delete_session(session.id)
            raise SessionExpired
        return True
from exceptions.database_repo import FieldUniqueViolation
from interfaces import IModelReader
from .exceptions import UserDontExists, IncorrectPassword, SessionDontExists, SessionExpired


class UserAuthentication:
    def __init__(self, user_reader, session_getter, session_maker, user_getter, logger, hasher):
        self.user_reader: IModelReader = user_reader
        self.session_maker = session_maker
        self.hasher = hasher
        self.logger = logger
        self.user_getter = user_getter
        self.session_getter = session_getter


    def _get_user_by_name(self, name):
        return self.user_reader.get_by_kwargs(name=name)

    def validate_user_and_password(self, user_name, user, psw):
        if not user:
            raise UserDontExists(user_name)
        if not self.hasher.check_password(psw, user.password):
            raise IncorrectPassword

    def _get_session_by_user_id(self, user_id):
        return self.session_getter.get_session_id_by_user_id(user_id)


    def auth_by_name_and_psw(self, name, psw):
        user = self._get_user_by_name(name)
        if user is None:
            raise UserDontExists
        self.validate_user_and_password(name, user, psw)
        try:
            return self._get_session_by_user_id(user.id)
        except SessionDontExists or SessionExpired:
            return self.session_maker.make_session(user.id)

    def auth_by_session_id(self, session_id):
        return self.user_getter.get_user_by_session_id(session_id)


from interfaces import IModelActor

class SessionMaker:
    def __init__(self, session_expire_time, session_access, time_handler, hasher, cacher):
        self.expire_time = session_expire_time
        self._access: IModelActor = session_access
        self.time_handler = time_handler
        self.hasher = hasher
        self.cacher = cacher

    def _get_expire_date(self):
        return self.time_handler.add_days_to_current_date(self.expire_time)

    def _create_session_id(self):
        hashed_id = self.hasher.create_session_id_hash()
        return hashed_id

    def _create_session_obj(self, user_id):
        session_id = self._create_session_id()
        expire_date = self._get_expire_date()
        session_record = self._access.create_record(id=session_id, expire_date=expire_date, user_id=user_id)
        return session_record

    def make_session(self, user_id):
        session = self._create_session_obj(user_id)
        session_id = session.id
        self._access.write_record_to_db(session)
        self.cacher.put_data(session_id, user_id)
        return session_idfrom .exceptions import UserAlreadyExists
from exceptions.database_repo import FieldUniqueViolation

class UserRegistration:
    def __init__(self,user_actor, hasher, logger):
        self._user_actor = user_actor
        self.hasher = hasher
        self.logger = logger

    def create_user(self, name, password):
        try:
            password = self.hasher.generate_psw_hash(password)
            storage_id = self.hasher.generate_hash(16)
            self._user_actor.create_and_write_record_to_db(name=name, password=password, storage_id=storage_id)
        except FieldUniqueViolation:
                raise UserAlreadyExists(name)
        except Exception as e:
            self.logger.log(e)


class UserLogout:
    def __init__(self, session_deleter):
        self.session_deleter = session_deleter



    def logout_user(self, request, response):
        """
        :param response: something to get cookies from
        :param request: something to put/delete cookies from
        if your framework doesn't have something like this params then create class which wraps your framework's
        cookies system and allows to use the call chain obj.cookies.get() & cookies.delete()
        """
        session_id = request.cookies.get('session_id')
        if session_id is None:
            return
        response.delete_cookie('session_id')
        self.session_deleter.delete_session(session_id)class UserAlreadyExists(Exception):
    def __init__(self, name):
        msg = f'User with name {name} already exists'
        super().__init__(msg)

class Unauthorized(Exception):
    def __init__(self, name = None):
        msg = f'user {name} unauthorized'
        super().__init__(msg)

class UserDontExists(Exception):
    def __init__(self, name=None):
        msg = f'User with name {name} does not exists'
        super().__init__(msg)

class IncorrectPassword(Exception):
    def __init__(self):
        super().__init__()

class SessionExpired(Exception):
    def __init__(self):
        super().__init__()

class SessionDontExists(Exception):
    def __init__(self):
        super().__init__()from .router import browser_routerfrom .browser_endpoint_handler import BrowserEndpointHandlerfrom fastapi import HTTPException
from path_explorator import PathGoesBeyondLimits

from exceptions import APIEntityDoesNotExists, EntityDoesNotExists, APIPathGoesBeyondLimits
from interfaces import ILogger, IStorageReader, IPathCutter


class BrowserEndpointHandler:
    def __init__(self, storage_reader, logger, path_joiner, path_cutter, path_ensurer):
        self.storage_reader: IStorageReader = storage_reader
        self.path_ensurer = path_ensurer
        self.logger: ILogger = logger
        self.path_joiner = path_joiner
        self.path_cutter: IPathCutter = path_cutter

    def _get_abs_path(self, storage_path, path_to_dir):
        path_with_storage_id = self.path_joiner.join_paths(storage_path, path_to_dir)
        return self.storage_reader.join_with_root_path(path_with_storage_id)

    def _get_all_entitynames_in_dir(self, rel_dir_path):
         return self.storage_reader.get_all_entitynames_in_dir(rel_dir_path)


    def get_list_of_entities(self, storage_id, path_in_storage: str | None):
        try:
            if path_in_storage is None:
                path_in_storage = ''
            self.path_ensurer.ensure_path_safety(storage_id, path_in_storage)
            path_in_storage_with_id = self.path_joiner.join_paths(storage_id, path_in_storage)
            entitynames = self._get_all_entitynames_in_dir(path_in_storage_with_id)
            return entitynames
        except EntityDoesNotExists:
            raise APIEntityDoesNotExists(path_in_storage)
        except PathGoesBeyondLimits:
            raise APIPathGoesBeyondLimits(path_in_storage)


    def _recursively_get_entities_by_pattern(self, pattern:str, searching_in):
        entities = self.storage_reader.find_entities_path(searching_in, pattern)
        return entities

    def search_entities_by_pattern(self, storage_id: str, pattern: str, searching_in: str):
        try:
            pattern = f'{pattern}*'
            if searching_in is None:
                searching_in = ''
            self.path_ensurer.ensure_path_safety(storage_id, searching_in)
            searching_in_path_with_id = self.path_joiner.join_paths(storage_id, searching_in)
            entities = self._recursively_get_entities_by_pattern(pattern, searching_in_path_with_id)
            return entities
        except Exception as e:
            if isinstance(e, HTTPException): raise
            self.logger.log(e)from fastapi.templating import Jinja2Templates

class BrowserViewHandler:
    def __init__(self, jinja2_templates):
        self.templates: Jinja2Templates = jinja2_templates


    def get_html_response(self, request, user):
        context = {'request': request, "user": user}
        return self.templates.TemplateResponse(request, 'browser.html', context)from fastapi import APIRouter, Depends, Query, Request
from fastapi.templating import Jinja2Templates
from pathlib import Path
from fastapi.responses import HTMLResponse

from app.singletones import storage_reader, logger, path_joiner, path_cutter, path_ensurer
from .handlers.browser_view_handler import BrowserViewHandler
from .schemas.response import GetEntitiesResponse, SearchEntitiesResponse
from .schemas.query import BrowserGetEntitiesQuery, BrowserSearchEntitiesQuery
from .handlers import BrowserEndpointHandler
from app.routes.dependencies import auth_depend

templates_dir = Path(__file__).parent / 'templates'
global_templates_dir = Path(__file__).parent.parent.parent / 'templates'
static_dir = Path(__file__).parent / 'static'
global_static_dir = Path(__file__).parent.parent.parent / 'static'



browser_router = APIRouter()

templates = Jinja2Templates(directory=[templates_dir, global_templates_dir])


browser_endpoint_handler = BrowserEndpointHandler(storage_reader, logger, path_joiner, path_cutter, path_ensurer)
browser_view_handler = BrowserViewHandler(templates)

@browser_router.get('/_get_entities', response_model=GetEntitiesResponse)
def get_entities_in_storage(params: BrowserGetEntitiesQuery = Query(),
                            user=Depends(auth_depend.auth)):
    entities = browser_endpoint_handler.get_list_of_entities(user.storage_id, params.path_in_storage)
    return {"entities": entities,
            "path_in_storage": params.path_in_storage}

@browser_router.get('/_get_entities/search', response_model=SearchEntitiesResponse)
def search_entities_by_pattern(user=Depends(auth_depend.auth), params: BrowserSearchEntitiesQuery = Query()):
    entities = browser_endpoint_handler.search_entities_by_pattern(user.storage_id, params.pattern, params.searching_in_path)
    return {"entities": entities}

@browser_router.get('/browser', response_class=HTMLResponse)
def view_storage(request: Request, user=Depends(auth_depend.auth_allow_unauthorized)):
    html_template_response = browser_view_handler.get_html_response(request=request, user=user)
    return html_template_response
from pydantic import BaseModel


class GetEntitiesResponse(BaseModel):
    path_in_storage: str | None
    entities: list[str] | list

class SearchEntitiesResponse(BaseModel):
    entities: list[str] | listfrom pydantic import BaseModel, Field


class BrowserGetEntitiesQuery(BaseModel):
    path_in_storage: str | None = None

class BrowserSearchEntitiesQuery(BaseModel):
    searching_in_path: str | None = None
    pattern: strfrom .browser import browser_router
from .storage_acting import storage_acting_router
from .upload import upload_router
from .authorization import auth_router
from .download import download_router
from .settings import settings_routerfrom .router import download_routerfrom fastapi import APIRouter, BackgroundTasks, Query, Depends

from .schemas.query import DownloadQuery
from .endpoint_handlers import FileResponseHandler
from app.singletones import archivator, logger, path_joiner, path_ensurer, storage_reader
from app.routes.dependencies import auth_depend

download_router = APIRouter()

file_response_handler = FileResponseHandler(archivator, storage_reader, logger, path_ensurer, path_joiner)



@download_router.get('/download-entity')
def download_entity_endpoint(background_tasks: BackgroundTasks, params: DownloadQuery = Query(), user=Depends(auth_depend.auth)):
    response = file_response_handler.get_response(user.storage_id, params.entity_path_in_storage)
    background_tasks.add_task(archivator.cleanup_temp_files)
    return responsefrom pydantic import BaseModel


class DownloadQuery(BaseModel):
    entity_path_in_storage: str
from fastapi.responses import FileResponse

from interfaces import IStorageReader, IArchivator, ILogger
from exceptions import APIEntityDoesNotExists, APIUnsupportedEntityType
from utils import get_encoded_string


class FileResponseHandler:
    def __init__(self, archivator, storage_reader, logger, path_validator, path_joiner):
        self.archivator: IArchivator = archivator
        self.storage_reader: IStorageReader = storage_reader
        self.path_joiner = path_joiner
        self.logger: ILogger = logger
        self.ensurer = path_validator
        self.encode_string = get_encoded_string

    def _make_response(self, path_to_entity):
        try:
            str_path_to_entity = path_to_entity.__str__()
            entity_name = self.storage_reader.get_name(str_path_to_entity)
            encoded_entity_name = self.encode_string(entity_name)
            return FileResponse(path_to_entity,
                                filename=f'{entity_name}',
                                headers={"Content-Disposition": f"attachment; filename*=UTF-8''{encoded_entity_name}"},
    )
        except Exception as e:
            self.logger.log(e)
            raise e

    def get_zip_file_response(self, path_in_storage_with_id):
        try:
            absolute_path_dir = self.storage_reader.join_with_root_path(path_in_storage_with_id)
            zip_path = self.archivator.create_large_zip(absolute_path_dir)
            return self._make_response(zip_path)
        except Exception as e:
            self.logger.log(e)

    def get_file_response(self, path_in_storage_with_id):
        absolute_path_file = self.storage_reader.join_with_root_path(path_in_storage_with_id)
        return self._make_response(absolute_path_file)


    def get_response(self, storage_id, entity_path_in_storage):
        entity_path_in_storage = self.path_joiner.join_paths(storage_id, entity_path_in_storage)
        self.ensurer.ensure_path_safety(storage_id, entity_path_in_storage)
        if not self.ensurer.is_exists(entity_path_in_storage):
            raise APIEntityDoesNotExists(entity_path_in_storage)
        if self.storage_reader.is_dir(entity_path_in_storage):
            return self.get_zip_file_response(entity_path_in_storage)
        if self.storage_reader.is_file(entity_path_in_storage):
            return self.get_file_response(entity_path_in_storage)
        else:
            raise APIUnsupportedEntityType(entity_path_in_storage=entity_path_in_storage)

from .file_response_handler import FileResponseHandlerfrom .router import storage_acting_routerfrom aiofiles.threadpool.utils import delegate_to_executor
from fastapi import APIRouter, Depends, Query

from .schemas.query import MakeDirInStorageQuery, DeleteEntityQuery
from .endpoint_handlers import MakeDirHandler, DeleteEntityHandler
from app.singletones import logger, storage_writer, path_joiner, path_ensurer
from app.routes.dependencies import auth_depend

storage_acting_router = APIRouter()

make_dir_handler = MakeDirHandler(logger, storage_writer, path_joiner, path_ensurer)
delete_entity_handler = DeleteEntityHandler(path_ensurer, storage_writer, path_joiner, logger)


@storage_acting_router.post('/make-dir-in-storage')
def make_dir_in_storage(user=Depends(auth_depend.auth), params: MakeDirInStorageQuery = Query()):
    make_dir_handler.make_dir_in_storage(user.storage_id, params.path_in_storage, params.name)

@storage_acting_router.delete('/delete-entity-in-storage')
def delete_entity(user=Depends(auth_depend.auth), params: DeleteEntityQuery = Query()):
    auth_depend.ask_for_password(params.password, user)
    delete_entity_handler.delete_entity(str(user.id), params.path_in_storage)
from pydantic import BaseModel, Field


class MakeDirInStorageQuery(BaseModel):
    path_in_storage: str | None = None
    name: str = Field(max_length=255, min_length=1)

class DeleteEntityQuery(BaseModel):
    password: str
    path_in_storage: str
from interfaces import IStorageWriter
from exceptions import APIDirectoryAlreadyExists


class MakeDirHandler:
    def __init__(self, logger, storage_writer, path_joiner, path_ensurer):
        self.logger = logger
        self.storage_writer: IStorageWriter = storage_writer
        self.path_joiner = path_joiner
        self.path_ensurer = path_ensurer

    def make_dir_in_storage(self,storage_id, path, name):
        if path is None:
            path = ''
        try:
            self.path_ensurer.ensure_path_safety(storage_id, path)
            path_with_storage_id = self.path_joiner.join_paths(storage_id, path)
            self.storage_writer.create_dir(path_with_storage_id, name)
        except FileExistsError:
            raise APIDirectoryAlreadyExistsfrom .make_dir_handler import MakeDirHandler
from .delete_dir_handler import DeleteEntityHandlerfrom interfaces import IStorageWriter
from exceptions import EntityDoesNotExists, APIEntityDoesNotExists


class DeleteEntityHandler:
    def __init__(self, path_ensurer, storage_writer, path_joiner, logger):
        self.path_ensurer = path_ensurer
        self.storage_writer: IStorageWriter = storage_writer
        self.path_joiner = path_joiner
        self.logger = logger

    def delete_entity(self, user_id, path_in_storage):
        try:
            if path_in_storage is None:
                path_in_storage = ''
            path_with_user_id = self.path_joiner.join_paths(user_id, path_in_storage)
            self.path_ensurer.ensure_path_safety(user_id, path_in_storage)
            self.storage_writer.delete_entity(path_with_user_id)
        except EntityDoesNotExists:
            raise APIEntityDoesNotExists(path_in_storage)
        except Exception as e:
            self.logger.log(e)from .router import auth_routerfrom fastapi import APIRouter, Request, Response, Query
from .endpoint_handlers import SignUpHandler, LogOutHandler, AuthHandler
from app.singletones import user_logouter, logger, user_reader, storage_writer, user_registrator, user_authenticator
from .schemas.query import AuthenticateQuery, SignUpQuery


auth_router = APIRouter()


logout_handler = LogOutHandler(user_logouter, logger)
sign_up_handler = SignUpHandler(user_registrator, storage_writer, user_reader)
auth_handler = AuthHandler(user_authenticator)


@auth_router.get('/_logout', name='auth-logout')
def log_out_endpoint(request: Request, response: Response):
    logout_handler.logout_user(request, response)


@auth_router.post('/_sign-up', name='auth-sign_up')
def sign_up_endpoint(params: SignUpQuery = Query()):
    sign_up_handler.sign_up(params)
    return {"message": 'successfully signed up'}

@auth_router.post('/_log-in', name='auth-login')
def authenticate(response: Response, request: Request, params: AuthenticateQuery = Query()):
    auth_handler.auth_with_psw_and_set_session_cookie(params.name, params.password, response, request)
    return {"message": 'successfully logged_in'}


@auth_router.get('/profile', name='view-profile')
def view_profile():
    return {"message": 'not implemented'}

@auth_router.get('/log-in', name='view-login')
def view_login():
    return {"message": 'not implemented'}

@auth_router.get('/sign-up', name='view-sign_up')
def view_sign_up():
    return {"message": 'not implemented'}




from pydantic import BaseModel, Field


class SignUpQuery(BaseModel):
    name: str = Field(max_length=16, min_length=1)
    password: str = Field(max_length=255)

class AuthenticateQuery(BaseModel):
    name: str
    password: str
from fastapi import Response, Request

from exceptions import APIIncorrectPassword, APIUserDontExists, \
    APISessionDontExists, APISessionExpired, APIUnauthorized
from auth.exceptions import SessionExpired, SessionDontExists, IncorrectPassword, UserDontExists
from config import SESSION_COOKIES_EXPIRE_TIME

class AuthHandler:
    def __init__(self, authenticator):
        self.authenticator = authenticator

    def set_session_id_cookie(self, session_id, response: Response):
        response.set_cookie(key="session_id", value=session_id, max_age=SESSION_COOKIES_EXPIRE_TIME,
                            samesite='lax', httponly=True)

    def check_password(self, password, user):
        self.authenticator.validate_user_and_password('', user, password)

    def auth_with_psw_and_set_session_cookie(self, name, password, response: Response, request: Request):
        try:
            if request.cookies.get('session_id'):
                return
            session_id = self.authenticator.auth_by_name_and_psw(name, password)
            self.set_session_id_cookie(session_id, response)
        except IncorrectPassword:
            raise APIIncorrectPassword(password)
        except UserDontExists:
            raise APIUserDontExists(name)

    def auth_with_session_id(self, session_id):
        try:
            if session_id is None:
                raise APIUnauthorized
            return self.authenticator.auth_by_session_id(session_id)
        except SessionExpired:
            raise APISessionExpired
        except SessionDontExists:
            raise APISessionDontExists
        except UserDontExists:
            raise APIUserDontExists


from .auth_handler import AuthHandler
from .logout_handler import LogOutHandler
from .sign_up_handler import SignUpHandlerfrom fastapi import Request, Response

from exceptions.database_repo import FieldUniqueViolation


class LogOutHandler:
    def __init__(self, user_logouter, logger):
        self.logouter = user_logouter
        self.logger = logger

    def logout_user(self, request: Request, response: Response):
        try:
            self.logouter.logout_user(request, response)
        except FieldUniqueViolation:
            return
        except Exception as e:
            self.logger.log(e)
from exceptions import APIUserAlreadyExists, APIUserStorageAlreadyExists
from auth.exceptions import UserAlreadyExists
from interfaces import IStorageWriter

class SignUpHandler:
    def __init__(self, user_registrator, storage_writer, user_reader):
        self.user_registrator = user_registrator
        self.storage_writer: IStorageWriter = storage_writer
        self.user_reader = user_reader


    def sign_up(self, params):
        try:
            self.user_registrator.create_user(params.name, params.password)
            user = self.user_reader.get_by_kwargs(name = params.name)
            self.create_user_storage(user.storage_id)
        except UserAlreadyExists:
            raise APIUserAlreadyExists(params.name)

    def create_user_storage(self, storage_id):
        try:
            self.storage_writer.create_dir('', storage_id, exist_ok=False)
        except FileExistsError:
            raise APIUserStorageAlreadyExistsfrom .router import upload_routerfrom fastapi import APIRouter, UploadFile, Query, Depends
from .schemas.query import UploadQuery
from .endpoint_handlers import UploadFileHandler
from app.singletones import storage_writer, path_ensurer, logger, path_joiner

from app.routes.dependencies import auth_depend

upload_router = APIRouter()

upload_handler = UploadFileHandler(storage_writer, path_ensurer, logger, path_joiner)

@upload_router.post('/upload-entity')
async def upload_entity_endpoint(files: list[UploadFile], params: UploadQuery = Query(), user=Depends(auth_depend.auth)):
    await upload_handler.save_files_to_storage(user.storage_id, params.path_in_storage, files)
    return {"message": 'successfully uploaded files'}
from pydantic import BaseModel


class UploadQuery(BaseModel):
    path_in_storage: str | None = None

class MakeDirInStorageQuery(BaseModel):
    path_in_storage: str | None = None
    name: str

from .upload_handler import UploadFileHandlerfrom exceptions import APIEntityDoesNotExists, APITooManyFiles
from interfaces import ILogger, IStorageWriter

class UploadFileHandler:
    def __init__(self, storage_writer, path_ensurer, logger, path_joiner):
        self.storage_writer: IStorageWriter = storage_writer
        self.path_ensurer = path_ensurer
        self.path_joiner = path_joiner
        self.logger: ILogger = logger
        self.max_upload_files = 20

    def create_rel_fpath_with_id(self, user_id, rel_path, fname:str):
        fname = fname.lstrip('/') #I DONT KNOW WHY BUT PATHLIB REFUSES TO JOIN PATHS/ IT JUST RETURNS FNAME AS IT WAS IF WE DONT REMOVE THIS SLASH
        fpath_and_name = self.join_fpath_and_fname(rel_path, fname)
        fpath_and_name = fpath_and_name.lstrip('/') # THE SAME PROBLEM
        return self.path_joiner.join_paths(user_id, fpath_and_name)

    def join_fpath_and_fname(self, fpath, fname):
        return f'{fpath}/{fname}'

    async def _iterate_and_save_files_to_storage(self, files: list, output_path, user_id):
        try:
            for file in files:
                rel_fpath_with_id = self.create_rel_fpath_with_id(user_id, output_path, file.filename)
                print(rel_fpath_with_id)
                await self.storage_writer.async_write_from_fastapi_uploadfile_to_file(file, rel_fpath_with_id)
        except FileNotFoundError:
            raise APIEntityDoesNotExists(output_path)
        except Exception as e:
            self.logger.log(e)
            raise e

    async def save_files_to_storage(self, storage_id, path_in_storage, files: list):
        if len(files) > self.max_upload_files:
            raise APITooManyFiles
        if path_in_storage is None:
            path_in_storage = ''
        self.path_ensurer.ensure_path_safety(storage_id, path_in_storage)
        await self._iterate_and_save_files_to_storage(files, path_in_storage, storage_id)

from .router import settings_routerfrom fastapi import APIRouter, Depends, Query, Request, Response

from ..dependencies import auth_depend
from .schemas.query import AccountDeleteQuery
from app.singletones import user_deleter, logger, user_logouter, storage_deleter

from .endpoint_handlers import SettingsHandler

settings_router = APIRouter()

settings_handler = SettingsHandler(user_deleter, logger, user_logouter, storage_deleter)

#TODO need to delete or safe-delete user's storage


@settings_router.delete('/settings/delete_acc')
def delete_user(request: Request,
                response: Response,
                user=Depends(auth_depend.auth),
                params: AccountDeleteQuery = Query()):

    auth_depend.ask_for_password(password=params.password, user=user)
    settings_handler.delete_account(str(user.id), params.should_delete_storage, request, response)
    return {"message": 'successfully deleted account'}

from pydantic import BaseModel


class AccountDeleteQuery(BaseModel):
    password: str
    should_delete_storage: bool = Falsefrom .settings_handler import SettingsHandler
class SettingsHandler:
    def __init__(self, acc_deleter, logger, user_logouter, storage_deleter):
        self.account_deleter = acc_deleter
        self.logger = logger
        self.logouter = user_logouter
        self.storage_deleter = storage_deleter

    def delete_storage(self, user_id):
        try:
            self.storage_deleter.delete_storage_by_user_id(user_id)
        except Exception as e:
            self.logger.log(e)

    def delete_account(self, user_id, should_delete, request, response):
        try:
            self.logouter.logout_user(request=request, response=response)
            self.account_deleter.delete_user_by_id(user_id)
            if should_delete:
                self.delete_storage(user_id)
        except Exception as e:
            self.logger.log(e)from app.routes.authorization.router import auth_handler
from depends import AuthDepend

auth_depend = AuthDepend(auth_handler)
from redis import Redis

from auth.user_deleter import UserDeleter
from utils import Logger, TimeHandler, PathCutter, PathJoiner, PathValidEnsurer, Hasher
from logic import StorageReader, StorageWriter, Archivator, StorageDeleter
from db_repository import ModelReader, ModelActor
from auth import UserRegistration, SessionGetter, UserLogout, UserAuthentication ,SessionValidator, SessionMaker, SessionDeleter, UserGetter
from cache_handler import RedisCacher
from alchemy import User, Session

from config import STORAGE_PATH, CACHE_EXPIRE_TIME, CACHE_HOST, CACHE_PORT, SESSION_EXPIRE_TIME

logger = Logger()
redis_client = Redis(host=CACHE_HOST, port=CACHE_PORT, decode_responses=True)
path_joiner = PathJoiner(STORAGE_PATH)
path_cutter = PathCutter(STORAGE_PATH)
path_ensurer = PathValidEnsurer(STORAGE_PATH, path_cutter, path_joiner)
archivator = Archivator()
time_handler = TimeHandler()
storage_reader = StorageReader(STORAGE_PATH, path_joiner, path_cutter)
storage_writer = StorageWriter(STORAGE_PATH)
storage_deleter = StorageDeleter(storage_writer)
hasher = Hasher()
redis_cacher = RedisCacher(redis_client, CACHE_EXPIRE_TIME)
user_reader = ModelReader(User, logger)
user_actor = ModelActor(User, logger)
session_reader = ModelReader(Session, logger)
session_actor = ModelActor(Session, logger)
session_deleter = SessionDeleter(redis_cacher, session_actor, session_reader)
session_validator = SessionValidator(time_handler, session_deleter)
session_maker = SessionMaker(int(SESSION_EXPIRE_TIME), session_actor, time_handler, hasher, redis_cacher)
session_getter = SessionGetter(session_reader, redis_cacher, session_validator, session_deleter)
user_getter = UserGetter(user_reader, session_reader, redis_cacher, session_validator)
user_registrator = UserRegistration(user_actor, hasher, logger)
user_authenticator = UserAuthentication(user_reader, session_getter, session_maker, user_getter, logger, hasher)
user_logouter = UserLogout(session_deleter)
user_deleter = UserDeleter(user_actor)from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from pathlib import Path

from .routes import download_router, settings_router, auth_router, upload_router ,storage_acting_router ,browser_router

browser_static_dir = Path(__file__).parent / 'routes/browser/static'
global_static_dir = Path(__file__).parent / 'static'

browser_static = StaticFiles(directory=browser_static_dir)
global_static = StaticFiles(directory=global_static_dir)


app = FastAPI()

app.mount('/browser/static', browser_static, 'browser_static')
app.mount('/static', global_static, 'static')

app.include_router(browser_router)
app.include_router(storage_acting_router)
app.include_router(download_router)
app.include_router(upload_router)
app.include_router(auth_router)
app.include_router(settings_router)from datetime import datetime


print(datetime.astimezone())from werkzeug.security import generate_password_hash, check_password_hash
from secrets import token_urlsafe

class Hasher:

    def generate_psw_hash(self, password):
        return generate_password_hash(password)

    def check_password(self, password, hashed_psw):
        return check_password_hash(hashed_psw, password)

    def create_session_id_hash(self):
        return token_urlsafe(32)

    def generate_hash(self, nbytes):
        return token_urlsafe(nbytes)from .path_validator import PathValidEnsurer
from .path_creator import PathJoiner
from .logger import Logger
from .text_encoding import get_encoded_string
from .path_cutter import PathCutter
from .time_handler import TimeHandler
from .hasher import Hasherfrom exceptions import NotAUserId

class PathCutter:
    def __init__(self, root_path):
        self.root_path = root_path

    def cut_path(self, path:str, cutting_part):
        return path.removeprefix(cutting_part)

    def get_user_id_from_abs_path(self, abs_path: str):
        path = abs_path.removeprefix(self.root_path)
        id = self.get_user_id_part_from_rel_path(path)
        if not id.isdigit():
            raise NotAUserId(abs_path)
        return id

    def get_user_id_part_from_rel_path(self, path:str) -> str:
        #path must look like '/<id>/some/path or '<id>/some/path
        if path[0] == '/':
            return path.split('/')[1]
        return path.split('/')[0]

    def remove_id_from_rel_path(self, rel_path):
        if rel_path[0] == '/':
            return rel_path[2:]
        return rel_path[1:]

from urllib.parse import quote


def get_encoded_string(string):
    return quote(string)

from pathlib import Path


class PathJoiner:
    def __init__(self, root_path):
        self.root_path = root_path


    @property
    def root(self):
        return self.root_path


    def join_paths(self, path1, path2):
        new_path = Path(path1, path2)
        return new_path.__str__()

    def join_with_root_path(self, path:str):
        return self.join_paths(self.root_path, path)

    def create_absolute_entity_path(self, storage_id, entity_path_in_storage):
        if entity_path_in_storage is None:
            entity_path_in_storage = ''
        abs_user_dir_path = self.create_absolute_user_dir_path(storage_id)
        abs_path = self.join_paths(abs_user_dir_path, entity_path_in_storage)
        return abs_path

    def create_absolute_user_dir_path(self, user_id):
        user_id = str(user_id)
        return self.join_with_root_path(user_id)from datetime import datetime, timedelta

class TimeHandler:
    def add_days_to_current_date(self, days):
        time_delta = timedelta(days=days)
        now = datetime.today()
        new_date = now + time_delta
        return new_date

    def is_date_future(self, date):
        return datetime.now().date() < date

    def get_today_date(self):
        return datetime.today()

    def get_str_today_date(self):
        return self.get_today_date().strftime('%d/%m/%Y')from logging import Logger as SiteLogger

class Logger:

    def __init__(self):
        self.red_log = "\033[1;31mLOG\033[0m"
        self.logger = SiteLogger

    def log(self, exception):
        print(f'{self.red_log}{exception}{self.red_log}')

    def decor_log(self, func):
        def wrapper(*args, **kwargs):
            try:
                result = func(*args, **kwargs)
                return result
            except Exception as e:
                Logger.log(e)
        return wrapper
from exceptions import APIPathGoesBeyondLimits
from exceptions import EntityDoesNotExists, PathGoesBeyondLimits
from interfaces import IPathCutter
from pathlib import Path


class PathValidEnsurer:

    def __init__(self, root_dir, path_cutter, path_creator):
        self.path_cutter: IPathCutter = path_cutter
        self.path_joiner = path_creator
        self.root_dir = root_dir

    def is_goes_beyond_limits(self, requesting_path: str | None):
        return not self.is_path_rel_to_another_path(requesting_path, self.root_dir.__str__())


    def is_path_rel_to_another_path(self, path: str | None, relative_to_path: str | None):
        if path is None:
            path = ''
        if relative_to_path is None:
            relative_to_path = ''
        path = Path(path).resolve()
        relative_to_path = Path(relative_to_path)
        if path.is_relative_to(relative_to_path):
           return True
        return False

    @property
    def root(self):
        return self.root_dir.__str__()

    def is_exists(self, path: str) -> bool:
        """
        Checks if specified path exists
        :param path: path to the entity checking
        :return: exists or not True or False
        """
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.exists()


    def is_file(self, path: str) -> bool:
        """
        Checks if specified entity is FILE
        :param path: path to entity
        :return: file or not
        """
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.is_file()


    def is_dir(self, path: str) -> bool:
        """
        Checks if specified entity is DIRECTORY/FOLDER
        :param path: path to entity
        :return: dir or not
        """
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.is_dir()



    def raise_if_goes_beyond_limits(self, limiting_path: str, requesting_path:str):
        """

        :param limiting_path:
        :param requesting_path:
        :return:
        """
        if self.is_goes_beyond_limits(limiting_path):
            raise PathGoesBeyondLimits(requesting_path)
        if not self.is_path_rel_to_another_path(requesting_path, limiting_path):
            raise PathGoesBeyondLimits(requesting_path)

    def raise_if_entity_dont_exists(self, path:str):
        if not self.is_exists(path):
            raise EntityDoesNotExists(path)

    def ensure_path_safety(self, storage_id: int, path_in_storage: str):
        try:
            abs_requesting_path = self.path_joiner.create_absolute_entity_path(storage_id, path_in_storage)
            abs_limiting_path = self.path_joiner.create_absolute_user_dir_path(storage_id)
            self.raise_if_goes_beyond_limits(abs_limiting_path, abs_requesting_path)
        except PathGoesBeyondLimits:
            raise APIPathGoesBeyondLimits(path_in_storage)


from .models import User, Sessionfrom sqlalchemy import Column, Integer, String, Boolean, create_engine, Date, ForeignKey
from sqlalchemy.orm import declarative_base

from config import DATABASE_URL

engine = create_engine(DATABASE_URL)


Base = declarative_base()


class User(Base):

    __tablename__ = "users"

    id = Column(Integer, primary_key=True, autoincrement=True)
    password = Column(String(255))
    name = Column(String(30), unique=True)
    is_admin = Column(Boolean, default=False)
    storage_id = Column(String(32), unique = True)

class Session(Base):
    __tablename__ = "sessions"

    id = Column(String(50), primary_key=True)
    user_id = Column(Integer, ForeignKey(User.id), unique=True)
    expire_date = Column(Date)

Base.metadata.create_all(bind=engine)

from pathlib import Path
from exceptions import EntityDoesNotExists, EntityIsNotADir


class StorageReader:
    def __init__(self, root_dir_abs_path: str, path_creator, path_cutter):
        self.root_dir = self.__init_root_dir(root_dir_abs_path)
        self._path_creator = path_creator
        self._path_cutter = path_cutter

    def __init_root_dir(self, root_dir_abs_path: str):
        if not isinstance(root_dir_abs_path, str):
            raise TypeError(f'root_dir_abs_path type must be str, not {type(root_dir_abs_path)}')
        root_dir = Path(root_dir_abs_path)

        if not root_dir.exists():
            raise EntityDoesNotExists(root_dir)

        return root_dir

    @property
    def root_path(self):
        return self.root_dir.__str__()

    def join_with_root_path(self, path: str):
        joined = self.root_dir.joinpath(Path(path)).__str__()
        return joined

    def get_all_filenames_in_dir(self, dirpath: str | None):
        """
        Returns names of all FILES in directory
        :param dirpath: directory getting files from
        :return: List of all files (strings) in specified directory
        """
        if dirpath is None:
            dirpath = ''
        if not isinstance(dirpath, str):
            raise TypeError(f'dirpath arg must be str, not {type(dirpath)}')
        path = Path(self.root_dir, dirpath)
        if not path.exists():
            raise EntityDoesNotExists(dirpath)
        if not path.is_dir():
            raise EntityIsNotADir(dirpath)
        filenames = [self._path_cutter.cut_path(str(fname), str(self.root_dir)) for fname in path.iterdir() if fname.is_file()]
        return filenames

    def get_all_entitynames_in_dir(self, dirpath: str | None):
        """
        Returns all ENTITIES names (entity = any file, folder)
        :param dirpath: directory getting entities from
        :return: list of all entities names (strings) in specified directory
        """
        if dirpath is None:
            dirpath = ''
        if not isinstance(dirpath, str):
            raise TypeError(f'dirpath arg must be str, not {type(dirpath)}')
        path = Path(self.root_dir, dirpath)
        if not path.exists():
            raise EntityDoesNotExists(dirpath)
        if not path.is_dir():
            raise EntityIsNotADir(dirpath)
        entities_names = [self._path_cutter.cut_path(str(entity), str(path)) for entity in path.iterdir()]
        return entities_names

    def find_entities_path(self, searching_in: str | None, pattern: str) -> list[str]:
        """
        Return list with paths of entity or entities that match a given pattern
        :param searching_in: path to directory in which to find
        :param pattern: pattern of entity name you need to find (example "fname.txt", "*.txt")
        :return: List with absolute paths (Path objects) or None
        """
        if searching_in is None:
            searching_in = ''
        if not isinstance(searching_in, str):
            raise TypeError(f'searching_in arg must be str, not {type(searching_in)}')
        if not isinstance(pattern, str):
            raise TypeError(f'pattern arg must be str, not {type(pattern)}')
        searchable_dir = Path(self.root_dir, searching_in)
        paths = [self._path_cutter.cut_path(str(path), str(searchable_dir)) for path in searchable_dir.rglob(pattern)]
        return paths

    def is_exists(self, path: str | None) -> bool:
        """
        Checks if specified path exists
        :param path: path to the entity checking
        :return: exists or not True or False
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.exists()

    def is_file(self, path: str | None) -> bool:
        """
        Checks if specified entity is FILE
        :param path: path to entity
        :return: file or not
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.is_file()

    def is_dir(self, path: str | None) -> bool:
        """
        Checks if specified entity is DIRECTORY/FOLDER
        :param path: path to entity
        :return: dir or not
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity = Path(self.root_dir, path)
        return entity.is_dir()

    def get_name(self, path: str | None) -> str:
        """
        Get name of entity from strlike path
        :param path: strlike path
        :return: str name of entity (example /home/user/hello.txt  will return hello.txt)
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path arg must be str, not {type(path)}')
        entity_path = Path(self.root_dir, path)
        return entity_path.name



from interfaces import IStorageWriter

class StorageDeleter:
    def __init__(self, storage_writer):
        self.storage_writer: IStorageWriter = storage_writer

    def delete_storage_with_recoverability(self, user_id):
        raise NotImplementedError

    def delete_storage_by_user_id(self, user_id):
        self.storage_writer.delete_entity(user_id)
from .storage_reader import StorageReader
from .archivator import Archivator
from .storage_writer import StorageWriter
from .storage_deleter import StorageDeleterimport shutil

from aiofiles import open as aio_open
from pathlib import Path
from exceptions.path_exc import EntityDoesNotExists


class StorageWriter:
    def __init__(self, root_dir_abs_path: str):
        if not isinstance(root_dir_abs_path, str):
            raise TypeError(f'root_dir_abs_path argument must be str, not {type(root_dir_abs_path)}')
        self.root_dir = Path(root_dir_abs_path)

    def delete_entity(self, path: str | None):
        entity = Path(self.root_dir, path)
        if entity.exists():
            if entity.is_dir():
                shutil.rmtree(entity)
            elif entity.is_file():
                entity.unlink()
        else:
            raise EntityDoesNotExists(path)


    def create_dir(self, path: str | None, name:str, exist_ok=True):
        """
        Creates directory/folder in specified path with specified name
        :param path: Path to the location of the future directory.
        The path must be relative to the root directory, which is passed as an argument to __init__ as root_dir_abs_path.
        This rule is used in every object where root_dir_abs_path is passed during initialization.
        you can set path param as empty string if you need to make dir in root_ dir
        :param name: name of dir
        :return: None
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path argument must be str, not {type(path)}')
        if not isinstance(name, str):
            raise TypeError(f'name argument must be str, not {type(path)}')
        root_dir = Path(self.root_dir, path, name)
        root_dir.mkdir(exist_ok=exist_ok)

    def create_file(self, path: str | None , name: str, exist_ok):
        """
        Create file in specified path with specified name
        :param path: Path to the location of the future file.
        The path must be relative to the root directory, which is passed as an argument to __init__ as root_dir_abs_path.
        This rule is used in every object where root_dir_abs_path is passed during initialization.
        you can set path param as empty string if you need to make file in root_ dir
        :param name: name of file
        :return: None
        """
        if path is None:
            path = ''
        if not isinstance(path, str):
            raise TypeError(f'path argument must be str, not {type(path)}')
        if not isinstance(name, str):
            raise TypeError(f'name argument must be str, not {type(path)}')
        path_to_future_file = Path(self.root_dir, path, name)
        path_to_future_file.touch(exist_ok=exist_ok)

    async def async_write_from_fastapi_uploadfile_to_file(self, source_file, output_file_path, exist_ok=True):
        """
        special method for fastapi uploading file to hard disk
        :param source_file: fastapi UploadFile object
        :param output_file_path: path where an actual file will be saved on hard disk
        :return: None
        """
        output_file_path = Path(self.root_dir, output_file_path)
        async with aio_open(output_file_path, 'wb') as output_file:
            while content := await source_file.read(1024):
                await output_file.write(content)from pathlib import Path
from tempfile import mkdtemp
from zipfile import ZipFile, ZIP_DEFLATED


class Archivator:
    def __init__(self):
        self._zip_path = None
        self.tmp_dir = Path(mkdtemp())

    def has_zip_path(self):
        return self._zip_path is not None

    def make_zip_in_tmp_dir(self, archivable_dir):
        return self.tmp_dir / f"{archivable_dir.name}.zip"

    def write_from_dir_to_zip(self, dir, zip):
        with ZipFile(zip, mode='w', compression=ZIP_DEFLATED, allowZip64=True, compresslevel=6) as zipf:
            for file_path in dir.rglob('*'):
                if file_path.is_file():
                    entity = file_path.relative_to(dir)
                    zipf.write(file_path, entity)

    def cleanup_temp_files(self):
        if self.has_zip_path():
            self._cleanup()
            self._zip_path = None

    def _cleanup(self):
        self._zip_path.unlink(missing_ok=True)

    def create_large_zip(self, archivable_dir_path: str) -> Path:
        archivable_dir = Path(archivable_dir_path)
        self._zip_path = self.make_zip_in_tmp_dir(archivable_dir)
        self.write_from_dir_to_zip(archivable_dir, self._zip_path)
        return self._zip_path
